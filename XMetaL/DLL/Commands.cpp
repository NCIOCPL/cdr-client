/*
 * Implementation of CCdrApp and DLL registration.
 *
 * To do: rationalize error return codes for automation commands.
 *
 * BZIssue::4767
 * BZIssue::5172 - Add support for pasting fragment ref into Target attribute.
 * JIRA::OCECDR-3732 - custom support for genetics syndrome picklist
 */

// Microsoft insists that this come first. :-(
#include "stdafx.h"

// System headers.
#include <direct.h>
#include <fstream>
#include <list>
#include <map>
#include <process.h>
#include <string>
#include <sstream>
#include <wchar.h>

// Other Microsoft headers.
#include <atlenc.h>
#include <windows.h>
#include "resource.h"

// Local headers.
#include "Cdr.h"
#include "CdrUtil.h"
#include "CheckIn.h"
#include "Commands.h"
#include "CommentDialog.h"
#include "EditElement.h"
#include "FindComments.h"
#include "FindMarkup.h"
#include "Glossify.h"
#include "RetrieveDialog.h"
#include "PassedValidation.h"
#include "ReviewMarkup.h"
#include "RevisionLevel.h"
#include "SaveDialog.h"
#include "SchemaPicklist.h"
#include "SearchDialog.h"
#include "ValidateDialog.h"



// Prevent annoying warning from compiler about Microsoft's own bugs.
#pragma warning(disable : 4503)


// Local functions.
static void     clearErrorList();
static CString  getBlobExtension(const CString& doc, const CString& type);
static void     getBlobFromFile(char*, CFile&, int);
static CString  getFullDocPath(_Document*);
static cdr::StringList*
                getSchemaValidValues(const CString, const CString);
static void     insertAudioSeconds(::DOMNode&, CFile&);
static void     insertImageDimensions(::DOMNode&, CFile&);
static bool     inSpanishSummary();
static bool     isLinkingElement(const CString&, const CString&);
static void     loadDocTypes();
static bool     openDoc(cdr::DOM&, const CString&, BOOL, const CString&);
static void     removeDoc(const CString&);
static bool     replaceAudioSeconds(::DOMNode&, CString);
static bool     replaceImageDimensions(::DOMNode&, CString, CString);
static void     setTitleBar();
static CString  stringFromVariant(const VARIANT FAR&);

// Local data.
static cdr::StringList      docTypeStrings;
static cdr::ValidValueSets  validValueSets;
static cdr::ElementSets     linkingElements;

// Global data.
CString CCommands::username;


/////////////////////////////////////////////////////////////////////////////
// This method was generated by a MSVC++ wizard.

STDMETHODIMP CCommands::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_ICommands,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


/**
 * Allow the user to make a decision about the disposition of markup.
 *
 * In this context "markup" refers to Insertion and Deletion wrappers.
 */
STDMETHODIMP CCommands::acceptOrRejectMarkup(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("acceptOrRejectMarkup");
    CReviewMarkup markupReviewDialog;
    markupReviewDialog.DoModal();

    return S_OK;
}

/**
 * Tell the CDR server to add an entry to the external mapping table.
 */
STDMETHODIMP CCommands::addGlossaryPhrase(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("addGlossaryPhrase");

    // Find the element with the current focus.
    ::Selection selection = cdr::getApp().GetSelection();
    ::DOMElement elem = selection.GetContainerNode();

    // Make sure we have a glossary term reference.
    if (!elem || elem.GetNodeName() != L"GlossaryTermRef") {
        ::AfxMessageBox(L"No GlossaryTermRef at current location");
        return S_OK;
    }

    // Extract the document ID (if there is one).
    CString docIdElem;
    CString docId = elem.getAttribute(L"cdr:href");
    if (!docId.IsEmpty())
        docIdElem = L"<CdrId>" + docId + L"</CdrId>";

    // Extract the text content of the element & determine usage.
    selection.SelectContainerContents();
    CString value = selection.GetText();
    CString usage = L"GlossaryTerm Phrases";
    CString language = L"English";
    if (inSpanishSummary()) {
        usage = L"Spanish GlossaryTerm Phrases";
        language = L"Spanish";
    }

    // Ask the server to add the phrase.
    try {
        cdr::CommandSet request("CdrAddExternalMapping");
        auto command = request.command;
        request.child_element(command, "Usage", usage);
        request.child_element(command, "Value", value);
        if (!docId.IsEmpty())
            request.child_element(command, "CdrId", docId);
        CWaitCursor wc;
        CString response_xml = CdrSocket::sendCommands(request);
        cdr::DOM response(response_xml);
        if (!cdr::showErrors(response))
            ::AfxMessageBox(language + L" glossary phrase added "
                            L"to external mapping table.");
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    return S_OK;
}

/**
 * Launch Internet Explorer with the Advanced Search admin menu.
 *
 *  @param retVal - pointer to the return value
 */
STDMETHODIMP CCommands::advancedSearch(int *retVal) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())
    *retVal = EXIT_FAILURE;

    cdr::trace_log("advancedSearch");
    COleDispatchDriver ie;
    if (!ie.CreateDispatch(L"InternetExplorer.Application")) {
        ::AfxMessageBox(L"Unable to launch Internet Explorer");
        return S_OK;
    }
    CString url = L"https://"
                + CdrSocket::getHostName()
                + L"/cgi-bin/cdr/AdvancedSearch.py?Session="
                + CdrSocket::getSessionString();
    DISPID dispid;
    OLECHAR* member = L"Navigate";
    HRESULT hresult = ie.m_lpDispatch->GetIDsOfNames(IID_NULL,
        &member, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (hresult != S_OK) {
        ::AfxMessageBox(L"Unable to launch Internet Explorer");
        return S_OK;
    }
    static BYTE parms[] = VTS_BSTR VTS_I4 VTS_BSTR
                          VTS_PVARIANT VTS_PVARIANT;
    COleVariant dummy;
    ie.InvokeHelper(dispid, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
        url, 0L, L"CdrAdvSearch", &dummy, &dummy);
    *retVal = EXIT_SUCCESS;
    return S_OK;
}

/**
 * Unlock the currently active checked-out CDR document.
 *
 *  @param pRet - pointer to the return value
 */
STDMETHODIMP CCommands::checkIn(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("checkIn");
    *pRet = 1;
    try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Get the currently active document.
        _Document doc = cdr::getApp().GetActiveDocument();
        if (!doc) {
            ::AfxMessageBox(L"There is no active document.");
            return S_OK;
        }

        // Extract control information from the document.
        DOMNode docElement = doc.GetDocumentElement();
        CdrDocCtrlInfo ctrlInfo;
        cdr::extractCtlInfo(docElement, ctrlInfo);
        if (ctrlInfo.docId.IsEmpty()) {
            ::AfxMessageBox(L"Document has never been stored in the CDR.");
            return S_OK;
        }

        // Ask the user for confirmation.
        CCheckIn checkIn;
        switch (checkIn.DoModal()) {
        case IDOK:
        {
            // Build the check-in command.
            cdr::CommandSet request("CdrCheckIn");
            auto command = request.command;
            request.set(command, "Abandon", "Y");
            request.set(command, "ForceCheckIn", "Y");
            request.child_element(command, "DocumentId", ctrlInfo.docId);
            if (!checkIn.m_comment.IsEmpty())
                request.child_element(command, "Comment", checkIn.m_comment);

            // Submit the check-in command to the server.
            CWaitCursor wc;
            CString response_xml = CdrSocket::sendCommands(request);
            cdr::DOM dom(response_xml);
            auto response = dom.find("CdrResponse");
            if (response) {
                if (!cdr::showErrors(dom)) {
                    if (dom.get(response, "Status") != "success")
                        ::AfxMessageBox(L"Unexplained failure");
                    else {
                        *pRet = 0;
                        doc.Close(2); // 2=don't save changes
                        removeDoc(ctrlInfo.docId);
                    }
                }
            }
            else
                ::AfxMessageBox(L"Missing response from CDR server");
            break;
        }
        case IDCANCEL:
            break;
        }
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }

    return S_OK;
}

/**
 * Let the user choose which revision level to apply to the selected
 * elements.
 *
 *  @param response_ - one of the valid revision level strings (return value)
 */
STDMETHODIMP CCommands::chooseRevisionLevel(BSTR* response_) {

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("chooseRevisionLevel");
    CString level;
    try {
        RevisionLevel dialog;
        if (dialog.DoModal() == IDOK) {
            switch (dialog.mRevisionLevel) {
            case 3:
                level = L"rejected";
                break;
            case 2:
                level = L"publish";
                break;
            case 1:
                level = L"proposed";
                break;
            default:
            case 0:
                level = L"approved";
            }
        }
    }
    catch (...) {
        ::AfxMessageBox(L"Internal error selecting revision level");
    }
    level.SetSysString(response_);

    return S_OK;
}

/**
 * Parses document ID and denormalized value from string argument
 * and inserts the former as a cdr:ref attribute and the latter
 * as the text content of the current element.  Private support
 * method.
 *
 *  @param  info    string returned by server containing document
 *                  ID and denormalized value for a link target;
 *                  the format of this string is "[id] text-content".
 *  @return         <code>true</code> if link inserted successfully.
 */
bool CCommands::doInsertLink(const CString& info) {
    bool inserted = false;
    CdrLinkInfo linkInfo = cdr::extractLinkInfo(info);
    if (linkInfo.target.IsEmpty())
        return inserted;

    // Find the source element for the link.
    ::Range selection = cdr::getApp().GetSelection();
    ::DOMElement elem = selection.GetContainerNode();
    while (elem && elem.GetNodeType() != 1) // DOMElement
        elem = elem.GetParentNode();
    if (elem) {

        // Determine whether this is a cdr:ref or cdr:href link.
        ::_Document doc = cdr::getApp().GetActiveDocument();
        ::DOMDocumentType docType = doc.GetDoctype();
        CString attrName;
        if (docType.GetHasAttribute(elem.GetNodeName(), L"cdr:ref"))
            attrName = L"cdr:ref";
        else
            attrName = L"cdr:href";

        // Plug in the link attribute.
        elem.setAttribute(attrName, linkInfo.target);

        // If this is a cdr:href link, that's all we need to do.
        if (attrName == L"cdr:href")
            return true;

        // Find the text node for the element.
        ::DOMText textNode = elem.GetFirstChild();
        while (textNode && textNode.GetNodeType() != 3) { // DOMText
            ::DOMText nextNode = textNode.GetNextSibling();
            if (textNode.GetNodeType() == 7) { // PI
                ::DOMProcessingInstruction pi(textNode);
                pi.m_bAutoRelease = 0;
                if (pi.GetTarget() == L"xm-replace_text")
                    ::DOMNode dummy = elem.removeChild(pi);
            }
            textNode = nextNode;
        }
        if (textNode)
            textNode.SetData(linkInfo.data);
        else {
            ::_Document curDoc = cdr::getApp().GetActiveDocument();
            textNode = curDoc.createTextNode(linkInfo.data);
            ::DOMNode dummy = elem.appendChild(textNode);
        }
        inserted = true;
    }

    return inserted;
}

/**
 * Common public method which factors out the code to retrieve and
 * open a CDR document.
 *
 * Called by:
 *   CCommands::openCdrDoc
 *   CCommands::retrieve
 *
 * Exceptions are caught by the callers.
 *
 *  @param  id              reference to CDR document ID.
 *  @return                 <code>true</code> if document retrieved
 *                          successfully.
 */
bool CCommands::doRetrieve(const CString& id,
                           BOOL checkOut,
                           const CString& version) {

    // Make sure the document isn't already open.
    _Application app = cdr::getApp();
    Documents docs = app.GetDocuments();
    unsigned int docNo = cdr::getDocNo(id);
    CString match;
    if (version != L"Current")
        match.Format(L"CDR%u-V%s ", docNo, version);
    else
        match.Format(L"CDR%u ", docNo);
    int matchLen = match.GetLength();
    for (long i = docs.GetCount(); i > 0; --i) {
        COleVariant vi;
        vi = i;
        _Document doc = docs.item(&vi);
        if (doc.GetTitle().Left(matchLen) == match) {
            if (!doc.GetSaved()) {
                int rc = ::AfxMessageBox(L"A modified copy of " + match +
                    L"is already open.\n" +
                    L"Do you want to abandon the changes?",
                    MB_YESNO);
                if (rc != IDYES)
                    return false;
            }
            doc.Close(2); // 2=Don't save changes.
        }
    }

    // Make canonical document ID.
    CString docId = cdr::docIdString(docNo);

    // Ask the server for the document.
    cdr::CommandSet request("CdrGetDoc");
    auto command = request.command;
    request.set(command, "includeBlob", "N");
    request.child_element(command, "DocId", docId);
    request.child_element(command, "Lock", checkOut ? "Y" : "N");
    request.child_element(command, "DocVersion", version);
    CString response = CdrSocket::sendCommands(request);
    cdr::DOM dom(response);
    return openDoc(dom, docId, checkOut, version);
}

/**
 * Allows user to edit the current node, which represents a link to
 * another CDR document, or a value controlled by the schema for this document
 * type. Yes, it's an odd name for this method. Why it was chosen is lost
 * in the sands of time.
 *
 *  @param  pRet - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::edit(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("edit");
    *pRet = 1;

    try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Find the currently active document.
        _Document doc = cdr::getApp().GetActiveDocument();

        // Extract the control information from the document.
        DOMNode docElement = doc.GetDocumentElement();
        CdrDocCtrlInfo ctrlInfo;
        cdr::extractCtlInfo(docElement, ctrlInfo);
        CString docType = docElement.GetNodeName();

        // Find the element with the current focus.
        ::Selection selection = cdr::getApp().GetSelection();
        CString elemName = selection.GetContainerName();

        // See if we have a valid-values set for this element.
        const cdr::StringList* validValues = getSchemaValidValues(docType,
                                                                  elemName);
        if (validValues) {
            CSchemaPicklist schemaPicklist(validValues, L"", elemName);
            if (schemaPicklist.DoModal() == IDOK)
                *pRet = 0;
            return S_OK;
        }

        // Check for custom flavors of this command.
        CEditElement::Type editType = CEditElement::NORMAL;
        if (docType == L"Person") {
            if (elemName  == L"OrganizationLocation") {
                if (selection.GetIsParentElement(L"OtherPracticeLocation"))
                    editType = CEditElement::ORG_LOCATION;
            }
            else if (elemName == L"FamilialCancerSyndrome")
                editType = CEditElement::GP_SYNDROME;
        }

        // Most of the real work is done inside this call.
        CEditElement editDialog(docType, elemName, editType);
        if (editDialog.DoModal() == IDOK)
            *pRet = 0;
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error from edit command.");
    }
    return S_OK;
}

/**
 * Provide GUI interface for editing the comment attribute of the current node.
 *
 *  @param readOnly - if VARIANT_TRUE just show the user the comment string
 *                    but don't let her edit it.
 */
STDMETHODIMP CCommands::editComment(VARIANT_BOOL readOnly) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("editComment");
    BOOL ro(readOnly);
    ::CCommentDialog dialog(ro);
    dialog.DoModal();

    return S_OK;
}

/*
 * Support for fetching information from the CDR web server.  Allows
 * us to implement simpler enhancements which would otherwise require
 * a rebuild of the CDR server.
 *
 *  @param response_ - return value for string fetched from server
 */
STDMETHODIMP CCommands::fetchFromUrl(const BSTR* url_, BSTR* response_) {

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("fetchFromUrl");
    CString url(*url_);
    CString response;
    try {
        response = cdr::fetchFromUrl(url);
    }
    catch (...) {
        ::AfxMessageBox(L"Unable to open " + url);
        response = L"";
    }
    response.SetSysString(response_);

    return S_OK;
}

/**
 * Fetch the PDQBoardMemberInfo document ID for the current Person document.
 *
 *  @param personId - string containing the CDR ID of the active Person doc
 *  @param boardMemberId - return string for the linked document
 */
STDMETHODIMP CCommands::getBoardMemberId(const BSTR* personId,
                                         BSTR* boardMemberId) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getBoardMemberId");
    CString id(*personId);
    try {
        cdr::CommandSet request("CdrReport");
        auto command = request.command;
        request.child_element(command, "ReportName", "Board Member");
        auto params = request.child_element(command, "ReportParams");
        auto param = request.child_element(params, "ReportParam");
        request.set(param, "Name", "PersonId");
        request.set(param, "Value", id);
        CString response_xml = CdrSocket::sendCommands(request);
        cdr::DOM dom(response_xml);
        CString member_id = dom.get_text(dom.find("//BoardMember"));
        if (member_id.IsEmpty())
            cdr::showErrors(dom);
        member_id.SetSysString(boardMemberId);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }

    return S_OK;
}

/**
 * Fetch the ID of the term name documents associated with this concept doc.
 *
 *  @param conceptId   - string containing the CDR ID for the active
 *                       GlossaryTermConcept document
 *  @param termNameIds - string of term name document IDs, space delimited
 */
STDMETHODIMP CCommands::getGlossaryTermNameIds(const BSTR* conceptId,
                                               BSTR* termNameIds) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getGlossaryTermNameIds");
    CString id(*conceptId);
    CString ids;
    try {
        cdr::CommandSet request("CdrReport");
        auto command = request.command;
        request.child_element(command, "ReportName", "Glossary Term Names");
        auto params = request.child_element(command, "ReportParams");
        auto param = request.child_element(params, "ReportParam");
        request.set(param, "Name", "ConceptId");
        request.set(param, "Value", id);
        CString response_xml = CdrSocket::sendCommands(request);
        cdr::DOM dom(response_xml);
        if (!cdr::showErrors(dom)) {
            auto nodes = dom.find_all("//GlossaryTermName");
            CString sep;
            for (auto& node : nodes) {
                ids += sep + dom.get(node, "ref");
                sep = L" ";
            }
        }
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    ids.SetSysString(termNameIds);
    return S_OK;
}

/**
 * Fetch the term names associated with the current glossary concept doc.
 *
 *  @param conceptId - string containing the CDR ID for the active
 *                     GlossaryTermConcept document
 *  @param termNames - string returned to the caller showing all of the
 *                     term names linked to this concept document
 */
STDMETHODIMP CCommands::getGlossaryTermNames(const BSTR* conceptId,
                                             BSTR* termNames) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getGlossaryTermNames");
    CString id(*conceptId);
    CString names;
    try {
        cdr::CommandSet request("CdrReport");
        auto command = request.command;
        request.child_element(command, "ReportName", "Glossary Term Names");
        auto params = request.child_element(command, "ReportParams");
        auto param = request.child_element(params, "ReportParam");
        request.set(param, "Name", "ConceptId");
        request.set(param, "Value", id);
        CString response_xml = CdrSocket::sendCommands(request);
        cdr::DOM dom(response_xml);
        if (!cdr::showErrors(dom)) {
            auto nodes = dom.find_all("//GlossaryTermName");
            CString sep(L"    ");
            for (auto& node : nodes) {
                names += sep + dom.get_text(node);
                sep = L"\n    ";
            }
        }
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    names.SetSysString(termNames);
    return S_OK;
}

/**
 * String property for the current CDR server's host name.
 *
 *  @param pVal - address where the return string is passed back
 */
STDMETHODIMP CCommands::get_hostname(BSTR *pVal) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("get_hostname");
    CString hostname = CdrSocket::getHostName();
    hostname.SetSysString(pVal);

    return S_OK;
}

/**
 * Provide information about the next validation error.
 *
 *  @param valError - string with location and error message
 *                    delimited by '|'
 */
STDMETHODIMP CCommands::getNextValidationError(BSTR* valError) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getNextValidationError");
    CString result;
    _Document doc = cdr::getApp().GetActiveDocument();
    if (!doc) {
        result = L"0|No document is currently active";
        result.SetSysString(valError);
        return S_OK;
    }
    CString path = getFullDocPath(&doc);
    debug_log("looking up next validation error for " + path);
    if (path.IsEmpty()) {
        result = L"0|No validation results available";
        result.SetSysString(valError);
        return S_OK;
    }
    cdr::ValidationErrorSets::iterator iter =
        cdr::validationErrorSets.find(path);
    if (iter == cdr::validationErrorSets.end()) {
        result = L"0|No validation results available";
        result.SetSysString(valError);
        return S_OK;
    }
    cdr::ValidationErrors* errors = iter->second;
    if (errors->errors.size() < 1) {
        result = L"0|No validation errors found";
        result.SetSysString(valError);
        return S_OK;
    }
    if (errors->currentError >= errors->errors.size()) {
        result = L"0|No more validation errors found";
        result.SetSysString(valError);
        return S_OK;
    }
    const cdr::ValidationError* error = errors->getNextError();
    if (!error) {
        result = L"0|No more validation errors found";
        result.SetSysString(valError);
        return S_OK;
    }
    CString eid = error->eid;
    if (eid.IsEmpty())
        eid = L"0";
    result = eid + L"|" + error->message;
    if (!error->elevel.IsEmpty())
        result += L" (" + error->elevel + L")";
    result.SetSysString(valError);
    return S_OK;
}

/**
 * Insert a SpecificPostalAddresss element into the active Person document.
 *
 * Pulls in address information from the organization location block
 * linked from the current selection and inserts it so the user can
 * overide some of that information. See Jira ticket OCECDR-119.
 *
 *  @param pRet - pointer to the return value
 */
STDMETHODIMP CCommands::getOrgAddress(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("getOrgAddress");
    // Initial pessimism.
    *pRet = 1;

    try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Find the LeadOrgPersonnel element location.
        ::Range oplLoc = cdr::getElemRange(L"OtherPracticeLocation");
        if (!oplLoc) {
            ::AfxMessageBox(L"OtherPracticeLocation for "
                            L"current location not found");
            return S_OK;
        }

        // Find the adddress fragment link.
        ::DOMElement oplElem = oplLoc.GetContainerNode();
        if (!oplElem || oplElem.GetNodeName() != L"OtherPracticeLocation")
        {
            ::AfxMessageBox(L"Unable to find OtherPracticeLocation "
                            L"element");
            return S_OK;
        }
        ::DOMNodeList nodeList =
            oplElem.getElementsByTagName(L"OrganizationLocation");
        if (nodeList.GetLength() < 1) {
            ::AfxMessageBox(L"Unable to find OrganizationLocation element");

            return S_OK;
        }
        ::DOMElement orgLocElem = nodeList.item(0);
        CString addrLink = orgLocElem.getAttribute(L"cdr:ref");
        if (addrLink.IsEmpty()) {
            ::AfxMessageBox(L"Missing or empty cdr:ref attribute "
                            L"for address link");

            return S_OK;
        }

        // Break the link into its two parts.
        int delimPos = addrLink.Find(L"#");
        if (delimPos < 1 || delimPos == addrLink.GetLength() - 1) {
            ::AfxMessageBox(L"Malformed fragment link: " + addrLink);
            return S_OK;
        }
        CString docId = addrLink.Left(delimPos);
        CString fragId = addrLink.Mid(delimPos + 1);

        // Ask the server for the full address.
        cdr::CommandSet request("CdrFilter");
        auto command = request.command;
        auto filter_element = request.child_element(command, "Filter");
        request.set(filter_element, "Name", "Organization Address Fragment");
        auto parms = request.child_element(command, "Parms");
        auto parm = request.child_element(parms, "Parm");
        request.child_element(parm, "Name", "fragId");
        request.child_element(parm, "Value", fragId);
        auto document_element = request.child_element(command, "Document");
        request.set(document_element, "href", docId);

        // Submit the request to the CDR server.
        CWaitCursor wc;
        CString response_xml = CdrSocket::sendCommands(request);

        // Extract the address elements.
        cdr::DOM response(response_xml);
        CString doc_xml = response.get_text(response.find("Document"));
        if (doc_xml.IsEmpty()) {
            if (!cdr::showErrors(response))
                ::AfxMessageBox(L"Unknown failure from filter");
            return S_OK;
        }
        cdr::DOM dom(doc_xml);
        auto postal_address = dom.find("PostalAddress");
        if (!postal_address) {
            ::AfxMessageBox(L"PostalAddress not found");
            return S_OK;
        }
        auto children = dom.find_all("*", postal_address);
        CString address_type = dom.get(postal_address, "AddressType");
        if (address_type.IsEmpty())
            address_type = L"US";
        cdr::DOM new_dom("SpecificPostalAddress");
        auto spa = new_dom.get_root();
        new_dom.set(spa, "AddressType", address_type);
        new_dom.set(spa, "xmlns:cdr", "cips.nci.nih.gov/cdr");
        for (auto& child : children)
            new_dom.append(spa, child);

        // Find the proper location for the address.
        ::Range spaLoc = cdr::findOrCreateChild(oplLoc,
                                                L"SpecificPostalAddress");
        if (!spaLoc) {
            ::AfxMessageBox(L"Failure creating SpecificPostalAddress element");
            return S_OK;
        }

        // Plug in our own data.
        CString spa_xml = new_dom.get_xml(spa);
        if (!spaLoc.GetCanPaste(spa_xml, FALSE))
            ::AfxMessageBox(L"Unable to insert " + spa_xml);
        else {
            spaLoc.PasteString(spa_xml);
            *pRet = 0;
        }

    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error retrieving contact address info");
    }

    return S_OK;
}

/**
 * Get the patient document ID for the summary matching this HP summary.
 *
 *  @param hpDocId - string for the health profession summary ID
 *  @param patientDocId - string for the return value
 */
STDMETHODIMP CCommands::getPatientDocId(const BSTR* hpDocId,
                                        BSTR* patientDocId) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getPatientDocId");
    CString id(*hpDocId);

    try {
        cdr::CommandSet request("CdrReport");
        auto command = request.get_root();
        request.child_element(command, "ReportName", "Patient Summary");
        auto params = request.child_element(command, "ReportParams");
        auto param = request.child_element(params, "ReportParam");
        request.set(param, "Name", "HPSummary");
        request.set(param, "Value", id);
        CString response_xml = CdrSocket::sendCommands(request);
        cdr::DOM response_dom(response_xml);
        auto node = response_dom.find("//PatientSummary");
        if (node) {
            CString patient_id = response_dom.get_text(node);
            patient_id.SetSysString(patientDocId);
        }
        else
            cdr::showErrors(response_dom);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error retrieving patient ID");
    }

    return S_OK;
}

/*
 * Count the non-markup characters in the current selection.
 *
 *  @param  pVal - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::get_selectionCharacterCount(int *pVal) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    ::Selection selection = cdr::getApp().GetSelection();
    CString characters = selection.GetText();
    int n = 0;
    TCHAR q = L'\0';
    bool in_tag = false;
    for (int i = 0; i < characters.GetLength(); ++i) {
        TCHAR c = characters[i];
        if (in_tag) {
            if (q) {
                if (c == q)
                    q = _T('\0');
            }
            else if (c == _T('>'))
                in_tag = false;
            else if (c == _T('"') || c == _T('\''))
                q = c;
        }
        else if (c == _T('<'))
            in_tag = true;
        else
            ++n;
    }
    *pVal = n;

    return S_OK;
}

/**
 * Property for the current login's session ID string.
 *
 *  @param pVal - pointer to the returned string value
 */
STDMETHODIMP CCommands::get_session(BSTR *pVal) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("get_session");
    CString session = CdrSocket::getSessionString();
    session.SetSysString(pVal);

    return S_OK;
}

/**
 * Find the CDR ID of the current English summary's translation.
 *
 *  @param originalId      - string containing the CDR ID of the active doc
 *  @param translatedDocId - return string for the Spanish summary document
 */
STDMETHODIMP CCommands::getTranslatedDocId(const BSTR* originalId,
                                           BSTR* translatedDocId) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getTranslatedDocId");
    _Document doc = cdr::getApp().GetActiveDocument();
    DOMNode docElement = doc.GetDocumentElement();
    CString docType = docElement.GetNodeName();
    CString reportName = L"";
    CString paramName = L"";
    CString xpath = L"";
    CString translationId;
    if (docType == L"Summary") {
        reportName = L"Translated Summary";
        paramName = L"EnglishSummary";
        xpath = L"//TranslatedSummary";
    }
    else if (docType == L"Media") {
        reportName = L"Translated Media Doc";
        paramName = L"EnglishMediaDoc";
        xpath = L"//TranslatedMediaDoc";
    }
    if (reportName.IsEmpty())
        ::AfxMessageBox(L"Unsupported document type " + docType);
    else {
        CString id(*originalId);
        try {
            cdr::CommandSet request("CdrReport");
            auto command = request.command;
            request.child_element(command, "ReportName", reportName);
            auto params = request.child_element(command, "ReportParams");
            auto param = request.child_element(params, "ReportParam");
            request.set(param, "Name", paramName);
            request.set(param, "Value", id);
            CString response_xml = CdrSocket::sendCommands(request);
            cdr::DOM response_dom(response_xml);
            auto node = response_dom.find(xpath);
            if (node)
                translationId = response_dom.get_text(node);
            else
                cdr::showErrors(response_dom);
        }
        catch (::CException* e) {
            e->ReportError();
            e->Delete();
        }
        catch (const wchar_t* e) {
            ::AfxMessageBox(e);
        }
        catch (...) {
            ::AfxMessageBox(L"Unexpected error retrieving patient ID");
        }
    }
    translationId.SetSysString(translatedDocId);

    return S_OK;
}

/**
 * String property for the current user's CDR account name.
 *
 *  @param pVal - pointer for return value
 */
STDMETHODIMP CCommands::get_username(BSTR *pVal) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("get_username");
    username.SetSysString(pVal);

    return S_OK;
}

/**
 * String property for the client user directory.
 *
 *  @param pVal - pointer for return value
 */
STDMETHODIMP CCommands::get_userPath(BSTR* pVal) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("get_userPath");
    CString userPath = cdr::getUserPath();
    userPath.SetSysString(pVal);

    return S_OK;
}

/**
 * Launch the dialog box for glossifying the current document.
 *
 *  @param dig        - flag indicating whether we should recurse, looking
 *                      for top-level summary sections wrapped in Insertion
 *                      or Deletion elements
 *  @param dictionary - optional string narrowing the scope to terms for
 *                      a single dictionary
 */
STDMETHODIMP CCommands::glossify(VARIANT_BOOL dig, const BSTR* dictionary) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    cdr::trace_log("glossify");
    CString dict(*dictionary);
    CGlossify glossify(dig != VARIANT_FALSE, dict);
    glossify.DoModal();
    return S_OK;
}

/**
 * Let the caller know if the current element is blocked from modification.
 *
 *  @param docType  - string for the active document's document type
 *  @param elemName - string for the tag name of the current element
 *  @param pVal     - pointer to the returned Boolean value
 */
STDMETHODIMP CCommands::isReadOnly(const BSTR *docType,
                                   const BSTR *elemName,
                                   BOOL *pVal) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("isReadOnly");
    // Initial assumption: the element is not read-only.
    *pVal = FALSE;
    CString dt(*docType);
    CString el(*elemName);
    cdr::StringList* vvList = getSchemaValidValues(dt, el);
    if (vvList && !vvList->empty())
        *pVal = TRUE;
    else if (isLinkingElement(dt, el))
        *pVal = TRUE;
    // Stopgap until readonly attributes are in place.
    else if (el == "DocId" || el == "DocType")
        *pVal = TRUE;
    return S_OK;
}

/**
 * Execute the application associated with the active doc's attachment.
 *
 *  @param docId  - string with the CDR ID for the active document
 *  @param docVer - string with the optional version
 */
STDMETHODIMP CCommands::launchBlob(const BSTR* docId, const BSTR* docVer) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("launchBlob");
    CString id(*docId);
    CString ver(*docVer);
    CString fileName;
    std::ios_base::openmode mode = std::ios_base::binary | std::ios_base::out;
    int intId = cdr::getDocNo(id);
    fileName.Format(L"CDR%d", intId);
    if (!ver.IsEmpty())
        fileName += L"-" + ver;
    else
        ver = L"Current";

    // Construct the command to retrieve the document with its blob.
    try {
        cdr::CommandSet request("CdrGetDoc");
        auto command = request.command;
        request.set(command, "includeXml", "Y");
        request.set(command, "includeBlob", "Y");
        request.child_element(command, "DocId", id);
        request.child_element(command, "Lock", "N");
        request.child_element(command, "DocVersion", ver);
        CString response_xml = CdrSocket::sendCommands(request);

        // If parsing the response with the embedded blob puts too
        // much of a strain on resources, we may have to revert to
        // extracting the blob part by hand. Test to find out.
        cdr::DOM response_dom(response_xml);
        auto doc_element = response_dom.find("//CdrDoc");
        if (!doc_element) {
            cdr::showErrors(response_dom);
            return S_OK;
        }
        CString doc_type = response_dom.get(doc_element, "Type");
        auto blob_element = response_dom.find("//CdrDocBlob");
        if (!blob_element) {
            ::AfxMessageBox(L"Binary object not found");
            return S_OK;
        }
        auto xml_element = response_dom.find("CdrDocXml", doc_element);
        if (!xml_element) {
            ::AfxMessageBox(L"Missing document XML");
            return S_OK;
        }
        CString xml = response_dom.get_text(xml_element);
        CString doc_blob = response_dom.get_text(blob_element);
        auto blob_len = doc_blob.GetLength();

        // Use a local buffer type to ensure memory release even if an
        // exception occurs.
        struct Buf {
            Buf(size_t n) : buf(new char[n]) { memset(buf, 0, n); }
            ~Buf() { delete [] buf; }
            char* buf;
        };
        int dst_len = ::Base64DecodeGetRequiredLength(blob_len);
        Buf blob((size_t)dst_len);
        auto bytes = cdr::cStringToUtf8(doc_blob).c_str();
        if (!::Base64Decode(bytes, blob_len, (BYTE*)blob.buf, &dst_len)) {
            ::AfxMessageBox(L"Failure decoding blob file");
            return S_OK;
        }


        // Save the file.
        CString path = cdr::getUserPath() + L"\\Cdr\\Media";
        ::CreateDirectory((LPCTSTR)path, NULL);
        path += L"\\" + fileName;
        CString ext = getBlobExtension(xml, doc_type);
        if (ext.IsEmpty()) {
            ::AfxMessageBox(L"Unable to determine filename extension");
            return S_OK;
        }
        path += ext;
        std::string pathName = cdr::cStringToUtf8(path);
        std::ofstream ofs(pathName.c_str(), mode);
        if (!ofs) {
            ::AfxMessageBox(L"Unable to write " + path);
            return S_OK;
        }
        ofs.write(blob.buf, dst_len);
        ofs.close();

        // Invoke the application registered by the user for this file type.
        ::ShellExecute(NULL, L"open", path, NULL, NULL, SW_SHOWNORMAL);
        return S_OK;
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error launching blob");
    }
    return S_OK;
}

/**
 * Ask the CDR server to log some troubleshooting information.
 *
 *  @param description - string to be logged
 *  @param pRet - pointer to the COM return value
 */
STDMETHODIMP CCommands::logClientEvent(const BSTR* description, int* pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("logClientEvent");
    *pRet = 0;
    CString desc(*description);
    try {
        cdr::CommandSet request("CdrLogClientEvent");
        request.child_element(request.command, "EventDescription", desc);
        CString response_xml = CdrSocket::sendCommands(request);
        cdr::DOM dom(response_xml);
        auto node = dom.find("//EventId");
        if (node) {
            wchar_t* end;
            *pRet = (int)wcstol(dom.get_text(node).GetString(), &end, 10);
        }
        else
            cdr::showErrors(dom);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error launching blob");
    }

    return S_OK;
}

/**
 * Log out of the CDR server.
 *
 *  @param  pRet - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::logoff(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("logoff");
    *pRet = 1;

    // Show the user the list of documents she still has checked out.
    if (!username.IsEmpty()) {
        try {
            cdr::CommandSet request("CdrReport");
            auto command = request.command;
            request.child_element(command, "ReportName", "Locked Documents");
            auto params = request.child_element(command, "Params");
            auto param = request.child_element(params, "Param");
            request.set(param, "Name", "UserId");
            request.set(param, "Value", username);
            CString response_xml = CdrSocket::sendCommands(request);
            cdr::DOM dom(response_xml);
            CString ids;
            CString sep;
            auto nodes = dom.find_all("//ReportRow/DocId");
            for (auto& node : nodes) {
                ids += sep + dom.get_text(node);
                sep = L", ";
            }
            if (!ids.IsEmpty()) {
                CString warning = L"The following documents are still "
                                  L"locked by your CDR account:\n" + ids;
                ::AfxMessageBox(warning);
            }
        }
        catch (::CException* e) {
            e->ReportError();
            e->Delete();
        }
        catch (const wchar_t* e) {
            ::AfxMessageBox(e);
        }
        catch (...) {
            ::AfxMessageBox(L"Unexpected error launching blob");
        }
    }

    // Clear out the property for the logged-in user's name.
    username = L"";

    try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            return S_OK;
        }

        // Submit the logoff request to the server.
        cdr::CommandSet request("CdrLogoff");
        CdrSocket::sendCommands(request);
        *pRet = 0;
    }
    catch (...) {}

    // Clear the session string so we'll know that we're no longer logged in.
    CdrSocket::setSessionString("");
    return S_OK;
}

/**
 * Log on to the CDR.
 *
 * The name of this command is misleading. The user is already logged
 * into the CDR (that took place in the CDR client loader). We're
 * just registering the knowledge of that login with the DLL and doing
 * some miscellaneous prep work, like loading the CDR document type
 * information from the disk.
 *
 *  @param  pRet - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::logon(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    // Start off assuming the worst.
    *pRet = 1;
    cdr::trace_log("logon");

    try {

        // Make sure the user isn't already logged on.
        if (CdrSocket::loggedOn())
            return S_OK;

        // Make sure the client machine has the refresh utility installed.
        CString manifestName = cdr::getUserPath() + L"\\CdrManifest.xml";
        if (_waccess((LPCTSTR)manifestName, 0)) {
            ::AfxMessageBox(L"Client files missing");
            return S_OK;
        }

        // Get the user ID and session credentials. If the environment
        // variables aren't set, the user wants to run XMetaL in a
        // standalone session.
        username = L"";
        const char* sessId = getenv("CDRSession");
        const char* userId = getenv("CDRUser");
        if (!sessId || !userId)
            return S_OK;
        username = userId;
        CdrSocket::setSessionString(sessId);

        // Identify who and where we are.
        setTitleBar();

        // Make the document directories if they aren't already there.
        CString cdrPath = cdr::getUserPath() + L"\\Cdr";
        CString roPath  = cdrPath + L"\\ReadOnly";
        CString coPath  = cdrPath + L"\\Checkout";
        CString mePath  = cdrPath + L"\\Media";
        _wmkdir((LPCTSTR)cdrPath);
        _wmkdir((LPCTSTR)roPath);
        _wmkdir((LPCTSTR)coPath);
        _wmkdir((LPCTSTR)mePath);

        // Get the document type information we need.
        loadDocTypes();
        *pRet = 0;
    }

    // Handle any extraordinary error conditions.
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* error) {
        ::AfxMessageBox(error);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected failure.");
    }
    return S_OK;
}

/**
 * Facilitate movement between comments in the active document.
 */
STDMETHODIMP CCommands::navigateComments(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("navigateComments");
    CFindComments *dialog = new CFindComments();
    dialog->Create(CFindComments::IDD);
    dialog->ShowWindow(SW_SHOW);

    return S_OK;
}

/**
 * Help the user move between the Insertion and Deletion elements.
 */
STDMETHODIMP CCommands::navigateMarkup(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("navigateMarkup");
    CFindMarkup *dialog = new CFindMarkup();
    dialog->Create(CFindMarkup::IDD);
    dialog->ShowWindow(SW_SHOW);

    return S_OK;
}

/**
 * Fetch and open the requested CDR document.
 *
 *  @param docId    - string for the CDR ID of the requested document
 *  @param docVer   - optional string for the version of the document to open
 *  @param checkOut - if VARIANT_TRUE then lock the document
 */
STDMETHODIMP CCommands::openCdrDoc(const BSTR* docId, const BSTR* docVer,
                                   VARIANT_BOOL checkOut) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("openCdrDoc");
    CString id(*docId);
    CString ver(*docVer);
    BOOL co(checkOut);
    try {
        doRetrieve(id, co, ver);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }

    return S_OK;
}

/**
 * Set link attribute and denormalized text for current linking element.
 *
 *  @param link - string containing the document ID for the link
 *  @param pRet - pointer to the method's COM return value
 */
STDMETHODIMP CCommands::pasteDocLink(const BSTR* link, int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("pasteDocLink");
    *pRet = 1;
    CString docLink(*link);

    // Make sure the user is logged on to the CDR.
    if (!CdrSocket::loggedOn()) {
        ::AfxMessageBox(L"This session is not logged into the CDR");
        return S_OK;
    }

    // Find the currently active document.
    _Document doc = cdr::getApp().GetActiveDocument();

    // Get the current element and the doc type.
    DOMNode docElement = doc.GetDocumentElement();
    CString docType = docElement.GetNodeName();
    ::Range selection = cdr::getApp().GetSelection();
    ::DOMElement elem = selection.GetContainerNode();
    CString elemName  = elem.GetNodeName();
    while (elem && elem.GetNodeType() != 1) // DOMElement
        elem = elem.GetParentNode();
    if (elem) {
        try {

            // Determine whether this is a cdr:ref or cdr:href link.
            ::DOMDocumentType dt = doc.GetDoctype();
            if (dt.GetHasAttribute(elem.GetNodeName(), L"cdr:href")) {

                // If this is a cdr:href link, this is all we need to do.
                elem.setAttribute(L"cdr:href", docLink);
                *pRet = 0;
                return S_OK;
            }

            // BZIssue::5172 - Add support for Target attribute.
            if (dt.GetHasAttribute(elem.GetNodeName(), L"Target")) {

                // If this is a Target link, this is all we need to do.
                elem.setAttribute(L"Target", docLink);
                *pRet = 0;
                return S_OK;
            }

            // Ask the server for the denormalized data.
            cdr::CommandSet request("CdrPasteLink");
            auto command = request.command;
            request.child_element(command, "SourceDocType", docType);
            request.child_element(command, "SourceElementType", elemName);
            request.child_element(command, "TargetDocId", docLink);
            CWaitCursor wc;
            CString response_xml = CdrSocket::sendCommands(request);
            cdr::DOM dom(response_xml);
            if (cdr::showErrors(dom))
                return S_OK;
            auto node = dom.find("//DenormalizedContent");
            if (!node) {
                ::AfxMessageBox(L"Server did not return denormalized content");
                return S_OK;
            }
            CString data = dom.get_text(node);
            if (data.IsEmpty()) {
                ::AfxMessageBox(L"Denormalized data empty");
                return S_OK;
            }

            // Plug in the link attribute.
            elem.setAttribute(L"cdr:ref", docLink);

            // Clear out the existing children.
            ::DOMNode child = elem.GetFirstChild();
            while (child) {
                ::DOMNode nextChild = child.GetNextSibling();
                ::DOMNode dummy = elem.removeChild(child);
                child = nextChild;
            }

            // Pop in the new content.
            ::DOMText textNode = doc.createTextNode(data);
            ::DOMNode dummy = elem.appendChild(textNode);
        }
        catch (::CException* e) {
            e->ReportError();
            e->Delete();
        }
        catch (const wchar_t* e) {
            ::AfxMessageBox(e);
        }
        catch (...) {
            ::AfxMessageBox(L"Unexpected error pasting doc link");
        }

    }
    *pRet = 0;

    return S_OK;
}

/**
 * Retrieves the CDR document represented by the document ID obtained
 * from the user.
 *
 *  @param  pRet - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::retrieve(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("retrieve");
    *pRet = 1;
    try {

        // Working variables.
        CString err;
        RetrieveDialog dialog;

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn())
            err = "This session is not logged into the CDR";
        // Ask the user which document to retrieve.
        if (err.IsEmpty()) {
            int rc = (int)dialog.DoModal();
            switch (rc) {
            case IDOK:
                if (doRetrieve(dialog.m_DocId, dialog.m_CheckOut))
                    *pRet = 0;
                break;
            case IDCANCEL:
                break;
            case -1:
            default:
                err = L"Internal failure";
                break;
            }
        }

        // Give the user any bad news.
        if (!err.IsEmpty())
            ::AfxMessageBox(err);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    return S_OK;
}

/**
 * Save the currently active document in the CDR repository.
 *
 *  @param  pRet - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::save(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("save");
    *pRet = 1;
    try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Get the currently active document.
        _Document doc = cdr::getApp().GetActiveDocument();
        if (!doc) {
            ::AfxMessageBox(L"There is no active document.");
            return S_OK;
        }

        // Extract control information from the document.
        DOMNode docElement = doc.GetDocumentElement();
        CdrDocCtrlInfo ctrlInfo;
        cdr::extractCtlInfo(docElement, ctrlInfo);
        CString docTitle = ctrlInfo.docTitle;
        if (docTitle.IsEmpty())
            docTitle = L"Server will replace this dummy title";

        // Ask the user for options to be used for the operation.
        bool blobPossible = false;
        if (ctrlInfo.docType == L"Media" ||
            ctrlInfo.docType == L"SupplementaryInfo")
            blobPossible = true;
        CSaveDialog saveDialog(ctrlInfo.readyForReview, blobPossible);
        switch (saveDialog.DoModal()) {
        case IDOK:
        {
            CWaitCursor wc;
            clearErrorList();
            cdr::ValidationErrors* val_errors = NULL;

            // Build the save command.
            CString& docId = ctrlInfo.docId;
            const char* unlock = saveDialog.m_checkIn ? "Y" : "N";
            CString& comment = saveDialog.m_comment;
            const char* tag = docId.IsEmpty() ? "CdrAddDoc" : "CdrRepDoc";
            cdr::CommandSet request(tag);
            auto command = request.command;
            request.child_element(command, "CheckIn", unlock);
            if (saveDialog.m_createVersion) {
                auto version = request.child_element(command, "Version", "Y");
                const char* pub = saveDialog.m_versionPublishable ? "Y" : "N";
                request.set(version, "Publishable", pub);
            }
            else
                request.child_element(command, "Version", "N");
            const char* validate = saveDialog.m_validate ? "Y" : "N";
            auto val = request.child_element(command, "Validate", validate);
            request.set(val, "ErrorLocators", "Y");
            request.child_element(command, "Echo", "Y");
            if (!comment.IsEmpty())
                request.child_element(command, "Reason", comment);
            auto cdr_doc = request.child_element(command, "CdrDoc");
            request.set(cdr_doc, "Type", ctrlInfo.docType);
            if (!ctrlInfo.docId.IsEmpty())
                request.set(cdr_doc, "Id", ctrlInfo.docId);
            auto ctl = request.child_element(cdr_doc, "CdrDocCtl");
            if (!ctrlInfo.docId.IsEmpty())
                request.child_element(ctl, "DocId", ctrlInfo.docId);
            request.child_element(ctl, "DocType", ctrlInfo.docType);
            request.child_element(ctl, "DocTitle", ctrlInfo.docTitle);
            if (saveDialog.m_docInactive)
                request.child_element(ctl, "DocActiveStatus", "I");
            char* review = saveDialog.m_readyForReview ? "Y" : "N";
            request.child_element(ctl, "DocNeedsReview", review);
            if (!comment.IsEmpty())
                request.child_element(ctl, "DocComment", comment);

            // Handle blob if present.
            char* blob = nullptr;
            int blobSize = 0;
            CFile blobFile;
            CString blobFilename = saveDialog.m_blobFilenameString;
            if (!blobFilename.IsEmpty()) {
                UINT flags = CFile::modeRead | CFile::shareDenyNone;
                if (!blobFile.Open((LPCTSTR)blobFilename, flags)) {
                    CString msg = "Failure loading " + blobFilename;
                    ::AfxMessageBox(msg);
                    return S_OK;
                }
                blobSize = (int)blobFile.GetLength();
                if (ctrlInfo.docType == L"Media") {
                    try {
                        // Harmless if blob isn't an image.
                        insertImageDimensions(docElement, blobFile);
                    }
                    catch (...) {
                        TCHAR* msg = L"Unable to set image dimensions";
                        ::AfxMessageBox(msg);
                    }
                    try {
                        // Shouldn't be a problem if this isn't an audio file.
                        insertAudioSeconds(docElement, blobFile);
                    }
                    catch (...) {
                        TCHAR* msg = L"Unable to set RunSeconds";
                        ::AfxMessageBox(msg);
                    }
                }
            }

            // Add the XML for the document, now that it's been tweaked.
            CString original_xml = doc.GetXml();
            request.add_cdr_document(cdr_doc, original_xml);

            // Use a local buffer type to ensure memory release even if an
            // exception occurs.
            struct Buf {
                Buf(size_t n) : buf(new char[n]) { memset(buf, 0, n); }
                ~Buf() { delete [] buf; }
                char* buf;
            };
            Buf blobBuf(blobSize);
            if (blobSize > 0) {
                try {
                    getBlobFromFile(blobBuf.buf, blobFile, blobSize);
                }
                catch (::CException* e) {
                    CString msg;
                    msg.Format(L"Failure loading %s", blobFilename);
                    ::AfxMessageBox(msg);
                    e->ReportError();
                    e->Delete();
                    return S_OK;
                }
                catch (...) {
                    CString msg;
                    msg.Format(L"Unknown failure loading %s", blobFilename);
                    ::AfxMessageBox(msg);
                    return S_OK;
                }
            }

            // Encode the blob if we have one.
            int encodedBlobSize = 0;
            if (blobSize)
                encodedBlobSize = Base64EncodeGetRequiredLength(blobSize);
            Buf encodedBlobBuffer(encodedBlobSize + 1);
            if (encodedBlobSize) {
                int written = encodedBlobSize;
                const BYTE* source = (const BYTE*)blobBuf.buf;
                blob = encodedBlobBuffer.buf;
                BOOL ok = Base64Encode(source, blobSize, blob, &written);
                if (!ok) {
                    ::AfxMessageBox(L"failure encoding blob");
                    return S_OK;
                }
                char* name = "CdrDocBlob";
                request.child_element(cdr_doc, name, BLOB_PLACEHOLDER);
            }

            // Submit the save command to the server.
            CTime start_time = CTime::GetCurrentTime();
            CString response = CdrSocket::sendCommands(request, blob);
            cdr::DOM response_dom(response);
            CTime end_time = CTime::GetCurrentTime();
            CTimeSpan elapsed_time = end_time - start_time;
            auto cdr_response = response_dom.find("CdrResponse");
            if (response_dom.get(cdr_response, "Status") != L"success") {
                if (!cdr::showErrors(response_dom)) {
                    debug_log(response);
                    ::AfxMessageBox(L"Failure without explanation");
                }
            }
            else {

                // Show the user any validation errors.
                *pRet = 0;
                val_errors = new cdr::ValidationErrors(response_dom);
                *pRet = (int)val_errors->errors.size();
                if (!*pRet) {
                    if (saveDialog.m_validate) {
                        CPassedValidation dlg(ctrlInfo.docId);
                        dlg.DoModal();
                    }
                    delete val_errors;
                    val_errors = nullptr;
                }
                auto id_node = response_dom.find("//DocId");
                if (!id_node) {
                    delete val_errors;
                    val_errors = nullptr;
                    ::AfxMessageBox(L"Unable to find document ID");
                }
                else {
                    CString doc_id = response_dom.get_text(id_node);
                    doc.Close(2); // 2=don't save changes.
                    CString msg = elapsed_time.Format(
                        L"Document stored successfully (elapsed: %M:%S)");
                    if (ctrlInfo.docId.IsEmpty())
                        msg += L"\nIt is now checked out to you.\n"
                            L"Please check in when processing is complete.";
                    ::AfxMessageBox(msg, MB_ICONINFORMATION);
                    if (!saveDialog.m_checkIn) {
                        openDoc(response_dom, doc_id, true, L"Current");
                        if (val_errors) {
                            doc = cdr::getApp().GetActiveDocument();
                            CString path = getFullDocPath(&doc);
                            cdr::validationErrorSets[path] = val_errors;
                        }
                    }
                    else {
                        delete val_errors;
                        val_errors = nullptr;
                        removeDoc(doc_id);
                    }
                }
            }
            break;
        }
        case IDCANCEL:
            break;
        }
    }
    catch (::COleDispatchException* ode) {
        CString msg;
        msg.Format(L"Dispatch Exception; error code: %lu\n"
                   L"From application: %s\n"
                   L"Description: %s", ode->m_wCode, ode->m_strSource,
                   ode->m_strDescription);
        ::AfxMessageBox(msg);
        ode->Delete();
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    return S_OK;
}

/**
 * Submits a search request (obtained from the user) to the CDR server
 * and allows the user to retrieve one of the documents found.
 *
 *  @param  pRet - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::search(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("search");
    *pRet = 1;
    try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Make sure the document type names got loaded.
        if (docTypeStrings.empty()) {
            ::AfxMessageBox(L"Document type information missing");
            return S_OK;
        }

        // Put up the dialog window.
        CSearchDialog searchDialog(docTypeStrings);

        // All the heavy lifting is done in this call.
        int rc = (int)searchDialog.DoModal();

        // Cancel means we're done, even for success. :-)
        if (rc == IDCANCEL)
            *pRet = 0;
        else
            ::AfxMessageBox(L"Internal error");
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected failure.");
    }

    return S_OK;
}

/**
 * Mark the XMetaL application window's title bar with our current tier.
 */
STDMETHODIMP CCommands::setTitleBar(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //cdr::trace_log("setTitleBar"); XXX too noisy; clutters the log
    CWnd* w = ::AfxGetMainWnd();
    if (w) {
        CString title;
        title.Format(L"CDR Editor (%s)", CdrSocket::getHostTier());
        w->SetWindowText(title);
    }

    return S_OK;
}

/**
 * Launch Internet Explorer (!) for a specific URL.
 *
 *  @param url  - string for the address the user has requested
 *  @param pRet - pointer to the method's return value
 */
STDMETHODIMP CCommands::showPage(const BSTR* url,  int* pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("showPage");
    CString urlString(*url);
    *pRet = cdr::showPage(urlString);
    return S_OK;
}

/**
 * Ask the CDR server to validate the currently active document.
 *
 *  @param  pRet - address of value returned for Microsoft Automation
 *                 (-1 for failure, otherwise number of validation errors
 *                 and/or warnings found).
 */
STDMETHODIMP CCommands::validate(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("validate");
    *pRet = -1;

    // Find the currently active document.
    _Document doc = cdr::getApp().GetActiveDocument();

    // Extract the document's control information.
    DOMNode docElement = doc.GetDocumentElement();
    CdrDocCtrlInfo ctrlInfo;
    cdr::ValidationErrors* valErrors = NULL;
    cdr::extractCtlInfo(docElement, ctrlInfo);
    if (ctrlInfo.docId.IsEmpty()) {
        ::AfxMessageBox(L"Document has never been saved");
        return S_OK;
    }

    try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Ask the user for options to be used during validation.
        CValidateDialog dlg;
        switch (dlg.DoModal()) {
        case IDOK:
        {
            CWaitCursor wc;

            clearErrorList();

            CString docType = docElement.GetNodeName();

            // Dialog box ensures that at least one is true.
            CString validation_types;
            if (dlg.m_schemaValidation) {
                if (dlg.m_linkValidation)
                    validation_types = L"Schema Links";
                else
                    validation_types = L"Schema";
            }
            else
                validation_types = L"Links";

            // Figure out how to resolve Insertion/Deletion markup.
            CString filter_level = L"3";
            if (dlg.m_includeProposedAndApprovedMarkup)
                filter_level = L"1";
            else if (dlg.m_includeApprovedMarkup)
                filter_level = L"2";

            // Build the validate command.
            cdr::CommandSet request("CdrValidateDoc");
            auto command = request.command;
            request.set(command, "DocType", docType);
            request.set(command, "ErrorLocators", "Y");
            request.set(command, "ValidationTypes", validation_types);
            request.set(command, "Id", ctrlInfo.docId);
            auto cdr_doc = request.child_element(command, "CdrDoc");
            request.set(cdr_doc, "Type", docType);
            request.set(cdr_doc, "RevisionFilterLevel", filter_level);
            auto doc_ctl = request.child_element(cdr_doc, "CdrDocCtl");
            if (!ctrlInfo.docId.IsEmpty())
                request.child_element(doc_ctl, "DocId", ctrlInfo.docId);
            request.child_element(doc_ctl, "DocTitle", ctrlInfo.docTitle);
            CString original_xml = doc.GetXml();
            request.add_cdr_document(cdr_doc, original_xml);

            // Submit the validate command to the server.
            CString response_xml = CdrSocket::sendCommands(request);
            cdr::DOM response_dom(response_xml);
            valErrors = new cdr::ValidationErrors(response_dom);
            *pRet = (int)valErrors->errors.size();
            if (*pRet) {
                CString path = getFullDocPath(&doc);
                CString msg;
                msg.Format(L"saving %d errors for %s", *pRet, path);
                debug_log(msg);
                cdr::validationErrorSets[path] = valErrors;
                CString version = L"Current";
                bool checkOut = path.Find(L"Checkout") != -1;
                int verPos = path.Find(L"-V");
                if (verPos != -1) {
                    version = path.Mid(verPos + 2);
                    version = version.Left(version.GetLength() - 4);
                }
                doc.Close(2); // 2=don't save changes.
                openDoc(response_dom, ctrlInfo.docId, checkOut, version);
            }
            else {
                delete valErrors;
                valErrors = nullptr;
                CPassedValidation dlg(ctrlInfo.docId);
                dlg.DoModal();
            }
            break;
        }
        case IDCANCEL:
            break;
        }
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error from validation command.");
    }
    return S_OK;
}

/*
 * Ask the CDR Server to find the values found at a specified
 * path in a specific CDR document.  Returns the list of values
 * in a single string, using the ASCII RS (record separator)
 * as delimiter between the values, since this control character
 * is not permitted in XML documents.  If it's possible to
 * return an array of strings from a COM object, I was unable
 * to find documentation for this feature.
 *
 *  @param docId  - CDR document ID string in canonical form
 *  @param path   - string for location in the document to search
 *  @param values - pointer to string for return value
 */
STDMETHODIMP CCommands::valuesForPath(const BSTR* docId, const BSTR* path,
                                      BSTR* values) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("valuesForPath");
    CString RS = L"\x0E";
    CString id(*docId);
    CString p(*path);
    cdr::CommandSet request("CdrReport");
    auto command = request.command;
    request.child_element(command, "ReportName", L"Values For Path");
    auto params = request.child_element(command, "ReportParams");
    auto param1 = request.child_element(params, "ReportParam");
    auto param2 = request.child_element(params, "ReportParam");
    request.set(param1, "Name", "DocId");
    request.set(param1, "Value", id);
    request.set(param2, "Name", "Path");
    request.set(param2, "Value", p);
    CString response_xml = CdrSocket::sendCommands(request);
    cdr::DOM dom(response_xml);
    auto nodes = dom.find_all("//Value");
    CString result = L"";
    CString sep = L"";
    for (auto& node : nodes) {
        result += sep + dom.get_text(node);
        sep = RS;
    }
    result.SetSysString(values);

    return S_OK;
}


//----------------------------------------------------------------------
//                       LOCAL SUPPORTING FUNCTIONS
//----------------------------------------------------------------------

/**
 * Empty the in-memory list of validation errors.
 *
 * Called by:
 *   CCommands::save()
 */
static void clearErrorList() {
    _Document doc = cdr::getApp().GetActiveDocument();
    if (doc) {
        CString path = getFullDocPath(&doc);
        if (!path.IsEmpty()) {
            cdr::ValidationErrorSets::iterator iter =
                cdr::validationErrorSets.find(path);
            if (iter != cdr::validationErrorSets.end()) {
                delete iter->second;
                cdr::validationErrorSets.erase(iter);
            }
        }
    }
}

/**
 * Find out which file name extension belongs with this document's attachment.
 *
 * Called by:
 *   CCommands::launchBlob()
 *
 *  @param docXml  - string containing the document's serialized XML
 *  @param docType - string containing the document's type name
 *
 * Return:
 *   string (with leading period) for the attachment's file name if knowable,
 *   otherwise empty string
 */
static CString getBlobExtension(const CString& docXml,
                                const CString& docType) {
    CString extension;
    cdr::DOM dom(docXml);
    if (docType == L"Media") {
        auto node = dom.find("//ImageEncoding");
        if (!node)
            node = dom.find("//VideoEncoding");
        if (!node)
            node = dom.find("//SoundEncoding");
        if (node)
            extension = L"." + dom.get_text(node);
    }
    else if (docType == L"SupplementaryInfo") {
        CString mime_type = dom.get_text(dom.find("MimeType"));
        if (mime_type == L"application/pdf")
            extension = L".pdf";
        else if (mime_type == L"application/msword")
            extension = L".doc";
        else if (mime_type == L"application/vnd.ms-excel")
            extension = L".xls";
        else if (mime_type ==
                 L"vnd.openxmlformats-officedocument.spreadsheetml.sheet")
            extension = L".xlsx";
        else if (mime_type == L"application/vnd.wordperfect")
            extension = L".wpd";
        else if (mime_type == L"text/html")
            extension = L".html";
        else if (mime_type == L"text/rtf")
            extension = L".rtf";
        else if (mime_type == L"text/plain")
            extension = L".txt";
        else if (mime_type == L"message/rfc822")
            extension = L".txt";
        else if (mime_type == L"image/jpeg")
            extension = L".jpg";
    }
    return extension.MakeLower();
}

/**
 * Load bytes for a document BLOB from the specified file.
 *
 * Called by:
 *   CCommands::save()
 *
 *  @param buf  - pointer to allocated byte buffer to be filled
 *  @param file - reference to object used to read the file's bytes
 *  @param len  - integer containing the number of bytes to be read
 */
static void getBlobFromFile(char* buf, CFile& file, int len) {
    int totalRead = 0;
    while (totalRead < len) {
        int bytesRead = file.Read(buf + totalRead, len - totalRead);
        if (bytesRead < 1)
            throw L"Failure reading from blob file";
        totalRead += bytesRead;
    }
}

/**
 * Assemble the absolute path to a specific document's file on the disk.
 *
 * Called by:
 *   CCommands::getNextValidationError()
 *   CCommands::save()
 *   CCommands::validate()
 *   clearErrorList()
 *
 *  @param doc - pointer to the document of interest
 *
 * Return:
 *   string for the document's location on disk
 */
static CString getFullDocPath(_Document* doc) {
    return doc->GetPath() + L"\\" + doc->GetName();
}

/**
 * Find the set of values valid for the current element.
 *
 * Called by:
 *   CCommands::edit()
 *   CCommands::isReadOnly()
 *
 *  @param docType - string for the name of the active document's type
 *  @param path    - identification of the currently selected element
 *
 * Return:
 *   pointer to a set of valid values if applicable, otherwise nullptr
 */
static cdr::StringList* getSchemaValidValues(const CString docType,
                                             const CString path)
{
    if (validValueSets.find(docType) == validValueSets.end())
        return nullptr;
    cdr::ValidValueSet& vvSet = validValueSets[docType];
    if (vvSet.find(path) == vvSet.end())
        return nullptr;
    return &vvSet[path];
}

/**
 * Examine an audio file to get its run time duration and record it.
 *
 * Called by:
 *   CCommands::save()
 *
 *  @param docElement - reference to element in which the duration is set
 *  @param file       - reference to the object used to read the file's bytes
 */
static void insertAudioSeconds(::DOMNode& docElement, CFile& file) {

    // Start by blanking out the existing value, to prevent leaving
    // invalid information in the event that we're unable to determine
    // the correct new information.  If the element is not already
    // present, we do nothing.
    debug_log("clearing out AudioSeconds");
    if (!replaceAudioSeconds(docElement, L""))
        return;

    int seconds = cdr::getAudioSeconds(file);
    if (seconds >= 0) {
        CString s;
        s.Format(L"%d", seconds);
        debug_log(L"setting AudioSeconds to " + s);
        replaceAudioSeconds(docElement, s);
    }
}

/**
 * Examine an image file to get its dimensions and record them.
 *
 * Called by:
 *   CCommands::save()
 *
 *  @param docElement - reference to element in which the dimensions are set
 *  @param file       - reference to the object used to read the file's bytes
 */
static void insertImageDimensions(::DOMNode& docElement, CFile& file) {

    // Start by blanking out the existing values, to prevent leaving
    // invalid information in the event that we're unable to determine
    // the correct new information.  If the dimension elements are not
    // already present, we do nothing.
    if (!replaceImageDimensions(docElement, L"", L""))
        return;

    cdr::ImageDimensions dim;
    if (cdr::getImageDimensions(file, dim)) {
        CString height, width;
        height.Format(L"%ld", dim.height);
        width.Format(L"%ld", dim.width);
        replaceImageDimensions(docElement, height, width);
    }

    // Restore file position for loading the entire blob.
    file.SeekToBegin();
}

/**
 * Determine whether the active document is a Spanish Summary document.
 *
 * Called by:
 *   CCommands::addGlossaryPhrase()
 *
 * Return:
 *   true iff the SummaryLanguage element has the text value "Spanish"
 */
static bool inSpanishSummary() {
    _Application app = cdr::getApp();
    ::_Document doc = app.GetActiveDocument();
    DOMNode docElement = doc.GetDocumentElement();
    CString docType = docElement.GetNodeName();
    if (docType == L"Summary") {
        ::DOMNode c = docElement.GetFirstChild();
        while (c) {
            if (c.GetNodeName() == L"SummaryMetaData") {
                ::DOMNode gc = c.GetFirstChild();
                while (gc) {
                    if (gc.GetNodeName() == L"SummaryLanguage") {
                        CString value = cdr::extractElementText(gc);
                        if (value == L"Spanish")
                            return true;
                    }
                    gc = gc.GetNextSibling();
                }
            }
            c = c.GetNextSibling();
        }
    }
    return false;
}

/**
 * Determines whether a given element in a particular document type can
 * link to another document or fragment.  Do this by checking the set of
 * linking elements we downloaded at startup.
 *
 * Called by:
 *   CCommands::isReadOnly()
 *
 *  @param  docType     string representing the document type.
 *  @param  elemName    string naming the element.
 *  @return             <code>true</code> iff the element can link to
 *                      another document or fragment.
 */
static bool isLinkingElement(const CString& docType,
                             const CString& elemName)
{
    if (linkingElements.find(docType) == linkingElements.end())
        return false;
    cdr::StringSet& ss = linkingElements[docType];
    return ss.find(elemName) != ss.end();
}

/**
 * Load document type information from the file system.
 *
 * Called by:
 *   CCommands::logon()
 *
 * Populates file-scope collections docTypeStrings and validValueSets.
 *
 * Throws a string-based exception if reading or parsing fails.
 */
static void loadDocTypes() {

    // Use a local buffer type to ensure memory release even if an
    // exception occurs.
    struct Buf {
        Buf(size_t n) : buf(new char[n]) { memset(buf, 0, n); }
        ~Buf() { delete [] buf; }
        char* buf;
    };
    CFile file;
    CString path = cdr::getUserPath() + L"\\CdrDocTypes.xml";
    file.Open((LPCTSTR)path, CFile::modeRead);
    int nBytes = (int)file.GetLength();
    if (nBytes <= 0)
        throw L"Missing document type information";

    Buf b((size_t)nBytes);
    int totalRead = 0;
    while (totalRead < nBytes) {
        int bytesRead = file.Read(b.buf + totalRead, nBytes - totalRead);
        if (bytesRead < 1)
            throw L"Failure reading from CdrDocTypes.xml";
        totalRead += bytesRead;
    }
    CString info = cdr::utf8ToCString(b.buf);

    // Populate these maps.
    docTypeStrings.clear();
    validValueSets.clear();
    docTypeStrings.push_back(L"Any Type");

    // Loop through the document types.
    cdr::DOM dom(info);
    auto responses = dom.find_all("CdrGetDocTypeResp");
    for (auto& response : responses) {
        if (dom.get(response, "Format") == L"xml") {
            CString doc_type = dom.get(response, "Type");
            docTypeStrings.push_back(doc_type);
            cdr::ValidValueSet vv_set;
            auto enum_sets = dom.find_all("EnumSet", response);
            for (auto& enum_set : enum_sets) {
                CString path = dom.get(enum_set, "Node");
                if (vv_set.find(path) == vv_set.end()) {
                    cdr::StringList& values = vv_set[path] = cdr::StringList();
                    auto elements = dom.find_all("ValidValue", enum_set);
                    for (auto& vv : elements) {
                        CString value = dom.get_text(vv);
                        values.push_back(cdr::decode(value));
                    }
                }
            }
            validValueSets[doc_type] = vv_set;
            cdr::StringSet names;
            CString path = L"LinkingElements/LinkingElement";
            auto elements = dom.find_all(path, response);
            for (auto& linking_element : elements) {
                CString name = dom.get_text(linking_element);
                if (!name.IsEmpty())
                    names.insert(name);
            }
            linkingElements[doc_type] = names;
        }
    }
}

/**
 * Open a new window in XMetaL with a CDR document.
 *
 * Called by:
 *   CCommands::doRetrieve()
 *   CCommands::save()
 *   CCommands::validate()
 *
 *  @param response     - parsed response from the CDR server
 *  @param docId    - string containing the CDR ID of the retrieved document
 *  @param checkOut - TRUE if the document was locked for editing
 *  @paranversion   - string with the version number (or "Current")
 */
static bool openDoc(cdr::DOM& response, const CString& docId, BOOL checkOut,
                    const CString& version) {

    // Create local variables needed by the method.
    _Application app = cdr::getApp();
    Documents docs = app.GetDocuments();
    unsigned int docNo = cdr::getDocNo(docId);
    CString err;
    CString blocked = L"N";
    CString docType;
    CString docPath;
    CString retrievedDocTitle;
    CString docTitle;
    CString cdrPath = cdr::getUserPath() + L"\\Cdr";

    // Find out if the document has been marked ReadyForReview.
    CString readyForReview = L"N";
    auto rrElement = response.find("//ReadyForReview");
    if (rrElement && response.get_text(rrElement) == L"Y")
        readyForReview = L"Y";

    // Build up path string.
    CString verPart = L"";
    if (version != L"Current")
        verPart.Format(L"-V%s", version);
    docPath.Format(L"%s\\%s\\CDR%u%s.xml",
                   (LPCTSTR)cdrPath,
                   checkOut ? L"Checkout" : L"ReadOnly",
                   docNo,
                   (LPCTSTR)verPart);

    // See if we got the document we asked for.
    auto cdrDocBlock = response.find("//CdrDoc");
    if (!cdrDocBlock) {

        // Log the response so we can examine it.
        char name[1024];
        time_t now = time(NULL);
        sprintf(name, "response-%lld.xml", (long long)now);
        std::ofstream responseStream(name, std::ios::binary);
        if (responseStream)
            responseStream << cdr::cStringToUtf8(response.get_xml()).c_str();
        err = response.get_text(response.find("//Errors/Err"));
        if (err.IsEmpty())
            err = L"Unknown failure retrieving document from CDR";
    }
    else {

        docType = response.get(cdrDocBlock, "Type");
        auto titleElement = response.find("DocTitle", cdrDocBlock);
        if (titleElement) {
            docTitle = response.get_text(titleElement);
            CString titleStart = docTitle.Left(15); // OCECDR-3914
            if (titleStart.GetLength() < docTitle.GetLength())
                titleStart += L'\x2026';
            retrievedDocTitle.Format(L"CDR%u%s%s - %s", docNo,
                                     (LPCTSTR)verPart,
                                     checkOut ? L"" : L" [RO]",
                                     (LPCTSTR)cdr::decode(titleStart));
        }
        auto statusElement = response.find("DocActiveStatus", cdrDocBlock);
        if (response.get_text(statusElement) == L"I")
            blocked = L"Y";
    }

    // Extract the DocXml.
    CString docXml;
    if (err.IsEmpty() && docType.IsEmpty())
        err = L"Missing Type attribute in CdrDoc element";
    if (err.IsEmpty()) {
        auto xmlElem = response.find("CdrDocXml", cdrDocBlock);
        docXml = response.get_text(xmlElem);
    }

    // Write out the document to the file system.
    if (!docXml.IsEmpty()) {
        std::string pathName = cdr::cStringToUtf8(docPath);
        std::ofstream xmlStream(pathName.c_str(), std::ios::binary);
        if (!xmlStream)
            err.Format(L"Can't write xml document at %s", (LPCTSTR)docPath);
        else {

            // Do some massaging (primarily insertion of the control block).
            try {
                cdr::DOM dom(docXml.Trim());
                auto root = dom.get_root();
                if (!checkOut)
                    dom.set(root, "readonly", "yes");
                CString tag = dom.get_node_name(root);
                if (tag != docType) {
                    CString msg;
                    msg.Format(L"Got %s doc instead of %s", tag, docType);
                    ::AfxMessageBox(msg);
                    return false;
                }
                auto docCtl = dom.element("CdrDocCtl");
                dom.set(docCtl, "readyForReview", readyForReview);
                dom.set(docCtl, "blocked", blocked);
                dom.child_element(docCtl, "DocId", docId);
                dom.child_element(docCtl, "DocTitle", docTitle);
                dom.insert(root, docCtl, dom.find("*", root));
                CString xmlDecl = L"<?xml version=\"1.0\"?>\n";
                CString dtd;
                CString dt(docType);
                dtd.Format(L"<!DOCTYPE %s SYSTEM '%s.dtd'>\n", dt, dt);
                CString newXml = xmlDecl + dtd + dom.get_xml(root);
                xmlStream << cdr::cStringToUtf8(newXml).c_str();
            }
            catch (::CException* e) {
                e->ReportError();
                e->Delete();
                return false;
            }
            catch (const wchar_t* error) {
                ::AfxMessageBox(error);
                return false;
            }
            catch (...) {
                ::AfxMessageBox(L"Failure preparing document for saving");
                return false;
            }
        }
    }

    // Show any bad news to the user.
    if (!err.IsEmpty()) {
        ::AfxMessageBox(err);
    }
    else {

        // Open the document and set its title bar string.
        try {
            _Document doc = docs.Open((LPCTSTR)docPath, 1);
            if (doc) {
                doc.SetTitle(retrievedDocTitle);
                return true;
            }
        }
        catch (::COleDispatchException* ode) {
            CString msg;
            msg.Format(L"Dispatch Exception; error code: %lu\n"
                       L"From application: %s\nDescription: %s",
                       ode->m_wCode, ode->m_strSource, ode->m_strDescription);
            ::AfxMessageBox(msg);
            ode->Delete();
        }
        catch (::CException* e) {
            e->ReportError();
            e->Delete();
        }
        catch (const wchar_t* e) {
            ::AfxMessageBox(e);
        }
        catch (...) {
            ::AfxMessageBox(L"Unexpected exception retrieving document");
        }
    }
    debug_log(L"leaving openDoc() in defeat");
    return false;
}

/**
 * Delete a CDR document from the file system.
 *
 * We only do this for locked documents which are being checked back in.
 *
 * Called by:
 *   CCommands::checkIn()
 *   CCommands::save()
 *
 *  @param docId - string containing the CDR ID for the document to be
 *                 removed
 */
static void removeDoc(const CString& docId) {
    unsigned int docNo = cdr::getDocNo(docId);
    CString cdrPath = cdr::getUserPath() + L"\\Cdr";
    CString docPath;
    docPath.Format(L"%s\\Checkout\\CDR%u.xml", (LPCTSTR)cdrPath, docNo);
    try {
        CFile::Remove((LPCTSTR)docPath);
    }
    catch (...) {}
}

/**
 * Set the duration of a SoundData block.
 *
 * Called by:
 *   insertAudioSeconds()
 *
 *  @param docElement - reference to node whose duration we set
 *  @param seconds    - string containing the number of runtime seconds
 */
static bool replaceAudioSeconds(::DOMNode& docElement, CString seconds) {
    ::DOMElement& elem = (::DOMElement&)docElement;
    ::DOMNodeList nodeList = elem.getElementsByTagName(L"SoundData");
    if (nodeList == 0 || nodeList.GetLength() < 1)
        return false;
    ::DOMElement dimElem = nodeList.item(0);
    ::DOMElement child = dimElem.GetFirstChild();
    while (child != 0) {
        if (child.GetNodeName() == L"RunSeconds") {
            cdr::replaceElementContent(child, seconds);
            debug_log("found and replaced RunSeconds value");
            return true;
        }
        child = child.GetNextSibling();
    }
    debug_log("couldn't find RunSeconds element");
    return false;
}

/**
 * Set height and width for an image element.
 *
 * Called by:
 *   insertImageDimensions()
 *
 *  @param docElement - reference to node whose dimensions we set
 *  @param height     - string for the height of the image
 *  @param width      - string for the width of the image
 */
static bool replaceImageDimensions(::DOMNode& docElement,
                                   CString height, CString width) {
    ::DOMElement& elem = (::DOMElement&)docElement;
    ::DOMNodeList nodeList = elem.getElementsByTagName(L"ImageDimensions");
    if (nodeList == 0 || nodeList.GetLength() < 1)
        return false;
    ::DOMElement dimElem = nodeList.item(0);
    ::DOMElement child = dimElem.GetFirstChild();
    bool foundHeight = false, foundWidth = false;
    while (child != 0) {
        if (child.GetNodeName() == L"HeightPixels") {
            cdr::replaceElementContent(child, height);
            foundHeight = true;
        }
        else if (child.GetNodeName() == L"WidthPixels") {
            cdr::replaceElementContent(child, width);
            foundWidth = true;
        }
        child = child.GetNextSibling();
    }
    return foundHeight && foundWidth;
}

/**
 * PROBABLY DON'T NEED THIS. XXX
 */
static void setTitleBar() {
    CWnd* w = ::AfxGetMainWnd();
    if (w) {
        CString title;
        title.Format(L"CDR Editor (%s)", CdrSocket::getHostTier());
        w->SetWindowText(title);
    }
}

/**
 * Converts a reference to an OLE VARIANT object to an MFC
 * string.  Recurses if necessary to handle additional levels
 * of indirection.
 *
 * XXX NOT USED
 *
 *  @param  v                   reference to OLE VARIANT object.
 *  @return                     newly created MFC CString object.
 */
static CString stringFromVariant(const VARIANT FAR& v)
{
    switch (v.vt) {
    case VT_BYREF | VT_VARIANT:
        return stringFromVariant(*v.pvarVal);
    case VT_BSTR:
        return CString(v.bstrVal);
    case VT_BYREF | VT_BSTR:
        return CString(*v.pbstrVal);
    default:
        return "";
    }
}
