/*
 * Implementation of CCdrApp and DLL registration.
 *
 * To do: rationalize error return codes for automation commands.
 *
 * BZIssue::4767
 * BZIssue::5172 - Add support for pasting fragment ref into Target attribute.
 * JIRA::OCECDR-3732 - custom support for genetics syndrome picklist
 */

// Microsoft insists that this come first. ¯\_(ツ)_/¯
#include "stdafx.h"

// System headers.
#include <direct.h>
#include <fstream>
#include <list>
#include <map>
#include <process.h>
#include <regex>
#include <string>
#include <sstream>
#include <wchar.h>

// Other Microsoft headers.
#include <atlenc.h>
#include <windows.h>
#include "resource.h"

// Local headers.
#include "Cdr.h"
#include "CdrUtil.h"
#include "CheckIn.h"
#include "Commands.h"
#include "CommentDialog.h"
#include "EditElement.h"
#include "FindComments.h"
#include "FindMarkup.h"
#include "Glossify.h"
#include "RetrieveDialog.h"
#include "PassedValidation.h"
#include "ReviewMarkup.h"
#include "RevisionLevel.h"
#include "SaveDialog.h"
#include "SchemaPicklist.h"
#include "SearchDialog.h"
#include "ValidateDialog.h"



// Prevent annoying warning from compiler about Microsoft's own bugs.
#pragma warning(disable : 4503)


// Local functions.
static void     clear_error_list();
static CString  get_blob_extension(const CString& doc, const CString& type);
static void     get_blob_from_file(char*, CFile&, int);
static CString  get_full_doc_path(_Document*);
static CString  get_location_id();
static cdr::StringList*
                get_schema_valid_values(const CString, const CString);
static void     insert_audio_seconds(::DOMNode&, CFile&);
static void     insert_image_dimensions(::DOMNode&, CFile&);
static bool     is_spanish_summary();
static void     load_doc_types();
static bool     move_to_location_id(const CString&, ::DOMNode&);
static bool     open_doc(cdr::DOM&, const CString&, BOOL, const CString&);
static void     remove_doc(const CString&);
static bool     replace_audio_seconds(::DOMNode&, CString);
static bool     replace_image_dimensions(::DOMNode&, CString, CString);
static void     set_title_bar();
static CString  string_from_variant(const VARIANT FAR&);

// Local data.
static cdr::StringList      doc_type_strings;
static cdr::ValidValueSets  valid_value_sets;
static cdr::ElementSets     linking_elements;

// Global data.
CString CCommands::username;


/////////////////////////////////////////////////////////////////////////////
// This method was generated by a MSVC++ wizard.

STDMETHODIMP CCommands::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_ICommands,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


/**
 * Allow the user to make a decision about the disposition of markup.
 *
 * In this context "markup" refers to Insertion and Deletion wrappers.
 */
STDMETHODIMP CCommands::acceptOrRejectMarkup(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("acceptOrRejectMarkup");
    CReviewMarkup dialog;
    dialog.DoModal();

    return S_OK;
}

/**
 * Tell the CDR server to add an entry to the external mapping table.
 */
STDMETHODIMP CCommands::addGlossaryPhrase(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("addGlossaryPhrase");

    // Find the element with the current focus.
    ::Selection selection = cdr::get_app().GetSelection();
    ::DOMElement elem = selection.GetContainerNode();

    // Make sure we have a glossary term reference.
    if (!elem || elem.GetNodeName() != L"GlossaryTermRef") {
        ::AfxMessageBox(L"No GlossaryTermRef at current location");
        return S_OK;
    }

    // Extract the document ID (if there is one).
    CString doc_id_elem;
    CString doc_id = elem.getAttribute(L"cdr:href");
    if (!doc_id.IsEmpty())
        doc_id_elem = L"<CdrId>" + doc_id + L"</CdrId>";

    // Extract the text content of the element & determine usage.
    selection.SelectContainerContents();
    CString value = selection.GetText();
    CString usage = L"GlossaryTerm Phrases";
    CString language = L"English";
    if (is_spanish_summary()) {
        usage = L"Spanish GlossaryTerm Phrases";
        language = L"Spanish";
    }

    // Ask the server to add the phrase.
    try {
        cdr::CommandSet request("CdrAddExternalMapping");
        auto command = request.command;
        request.child_element(command, "Usage", usage);
        request.child_element(command, "Value", value);
        if (!doc_id.IsEmpty())
            request.child_element(command, "CdrId", doc_id);
        CWaitCursor wc;
        CString response_xml = cdr::Socket::send_commands(request);
        cdr::DOM response(response_xml);
        if (!cdr::show_errors(response))
            ::AfxMessageBox(language + L" glossary phrase added "
                            L"to external mapping table.");
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    return S_OK;
}

/**
 * Launch Internet Explorer with the Advanced Search admin menu.
 *
 *  @param ret_val - pointer to the return value
 */
STDMETHODIMP CCommands::advancedSearch(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())
    *ret_val = EXIT_FAILURE;

    cdr::trace_log("advancedSearch");
    COleDispatchDriver ie;
    if (!ie.CreateDispatch(L"InternetExplorer.Application")) {
        ::AfxMessageBox(L"Unable to launch Internet Explorer");
        return S_OK;
    }
    CString url = L"https://"
                + cdr::Socket::get_host_name()
                + L"/cgi-bin/cdr/AdvancedSearch.py?Session="
                + cdr::Socket::get_session_string();
    DISPID dispid;
    OLECHAR* member = L"Navigate";
    HRESULT hresult = ie.m_lpDispatch->GetIDsOfNames(IID_NULL,
        &member, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (hresult != S_OK) {
        ::AfxMessageBox(L"Unable to launch Internet Explorer");
        return S_OK;
    }
    static BYTE parms[] = VTS_BSTR VTS_I4 VTS_BSTR
                          VTS_PVARIANT VTS_PVARIANT;
    COleVariant dummy;
    ie.InvokeHelper(dispid, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
        url, 0L, L"CdrAdvSearch", &dummy, &dummy);
    *ret_val = EXIT_SUCCESS;
    return S_OK;
}

/**
 * Unlock the currently active checked-out CDR document.
 *
 *  @param ret_val - pointer to the return value
 */
STDMETHODIMP CCommands::checkIn(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("checkIn");
    *ret_val = 1;
    try {

        // Make sure the user is logged on to the CDR.
        if (!cdr::Socket::logged_on()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Get the currently active document.
        _Document doc = cdr::get_app().GetActiveDocument();
        if (!doc) {
            ::AfxMessageBox(L"There is no active document.");
            return S_OK;
        }

        // Extract control information from the document.
        DOMNode doc_element = doc.GetDocumentElement();
        CdrDocCtrlInfo ctrl_info;
        cdr::extract_ctl_info(doc_element, ctrl_info);
        if (ctrl_info.doc_id.IsEmpty()) {
            ::AfxMessageBox(L"Document has never been stored in the CDR.");
            return S_OK;
        }

        // Ask the user for confirmation.
        CCheckIn check_in;
        switch (check_in.DoModal()) {
        case IDOK:
        {
            // Build the check-in command.
            cdr::CommandSet request("CdrCheckIn");
            auto command = request.command;
            request.set(command, "Abandon", "Y");
            request.set(command, "ForceCheckIn", "Y");
            request.child_element(command, "DocumentId", ctrl_info.doc_id);
            if (!check_in.m_comment.IsEmpty())
                request.child_element(command, "Comment", check_in.m_comment);

            // Submit the check-in command to the server.
            CWaitCursor wc;
            CString response_xml = cdr::Socket::send_commands(request);
            cdr::DOM dom(response_xml);
            auto response = dom.find("CdrResponse");
            if (response) {
                if (!cdr::show_errors(dom)) {
                    if (dom.get(response, "Status") != "success")
                        ::AfxMessageBox(L"Unexplained failure");
                    else {
                        *ret_val = 0;
                        doc.Close(2); // 2=don't save changes
                        remove_doc(ctrl_info.doc_id);
                    }
                }
            }
            else
                ::AfxMessageBox(L"Missing response from CDR server");
            break;
        }
        case IDCANCEL:
            break;
        }
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }

    return S_OK;
}

/**
 * Let the user choose which revision level to apply to the selected
 * elements.
 *
 *  @param response_ - one of the valid revision level strings (return value)
 */
STDMETHODIMP CCommands::chooseRevisionLevel(BSTR* response_) {

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("chooseRevisionLevel");
    CString level;
    try {
        RevisionLevel dialog;
        if (dialog.DoModal() == IDOK) {
            switch (dialog.m_revision_level) {
            case 3:
                level = L"rejected";
                break;
            case 2:
                level = L"publish";
                break;
            case 1:
                level = L"proposed";
                break;
            default:
            case 0:
                level = L"approved";
            }
        }
    }
    catch (...) {
        ::AfxMessageBox(L"Internal error selecting revision level");
    }
    level.SetSysString(response_);

    return S_OK;
}

/**
 * Parses document ID and denormalized value from string argument
 * and inserts the former as a cdr:ref attribute and the latter
 * as the text content of the current element.  Private support
 * method.
 *
 * Called by:
 *   CEditElement::OnSelectButton()
 *   CEditElement::insert_org_location()
 *
 *  @param  info    string returned by server containing document
 *                  ID and denormalized value for a link target;
 *                  the format of this string is "[id] text-content".
 *  @return         <code>true</code> if link inserted successfully.
 */
bool CCommands::doInsertLink(const CString& info) {
    bool inserted = false;
    CdrLinkInfo link_info = cdr::extract_link_info(info);
    if (link_info.target.IsEmpty())
        return inserted;

    // Find the source element for the link.
    ::Range selection = cdr::get_app().GetSelection();
    ::DOMElement elem = selection.GetContainerNode();
    while (elem && elem.GetNodeType() != 1) // DOMElement
        elem = elem.GetParentNode();
    if (elem) {

        // Determine whether this is a cdr:ref or cdr:href link.
        ::_Document doc = cdr::get_app().GetActiveDocument();
        ::DOMDocumentType doc_type = doc.GetDoctype();
        CString attr_name;
        if (doc_type.GetHasAttribute(elem.GetNodeName(), L"cdr:ref"))
            attr_name = L"cdr:ref";
        else
            attr_name = L"cdr:href";

        // Plug in the link attribute.
        elem.setAttribute(attr_name, link_info.target);

        // If this is a cdr:href link, that's all we need to do.
        if (attr_name == L"cdr:href")
            return true;

        // Find the text node for the element.
        ::DOMText text_node = elem.GetFirstChild();
        while (text_node && text_node.GetNodeType() != 3) { // DOMText
            ::DOMText next_node = text_node.GetNextSibling();
            if (text_node.GetNodeType() == 7) { // PI
                ::DOMProcessingInstruction pi(text_node);
                pi.m_bAutoRelease = 0;
                if (pi.GetTarget() == L"xm-replace_text")
                    ::DOMNode dummy = elem.removeChild(pi);
            }
            text_node = next_node;
        }
        if (text_node)
            text_node.SetData(link_info.data);
        else {
            ::_Document current_doc = cdr::get_app().GetActiveDocument();
            text_node = current_doc.createTextNode(link_info.data);
            ::DOMNode dummy = elem.appendChild(text_node);
        }
        inserted = true;
    }

    return inserted;
}

/**
 * Common public method which factors out the code to retrieve and
 * open a CDR document.
 *
 * Called by:
 *   CCommands::openCdrDoc
 *   CCommands::retrieve
 *
 * Exceptions are caught by the callers.
 *
 *  @param  id              reference to CDR document ID.
 *  @param  check_out       if true, lock the document for editing
 *  @param  version         which version to retrieve
 *  @return                 true if document retrieved successfully.
 */
bool CCommands::doRetrieve(const CString& id,
                           BOOL check_out,
                           const CString& version) {

    // Make sure the document isn't already open.
    _Application app = cdr::get_app();
    Documents docs = app.GetDocuments();
    unsigned int doc_no = cdr::get_doc_no(id);
    CString match;
    if (version != L"Current")
        match.Format(L"CDR%u-V%s ", doc_no, version);
    else
        match.Format(L"CDR%u ", doc_no);
    int match_len = match.GetLength();
    for (long i = docs.GetCount(); i > 0; --i) {
        COleVariant vi;
        vi = i;
        _Document doc = docs.item(&vi);
        if (doc.GetTitle().Left(match_len) == match) {
            if (!doc.GetSaved()) {
                int rc = ::AfxMessageBox(L"A modified copy of " + match +
                    L"is already open.\n" +
                    L"Do you want to abandon the changes?",
                    MB_YESNO);
                if (rc != IDYES)
                    return false;
            }
            doc.Close(2); // 2=Don't save changes.
        }
    }

    // Make canonical document ID.
    CString doc_id = cdr::doc_id_string(doc_no);

    // Ask the server for the document.
    cdr::CommandSet request("CdrGetDoc");
    auto command = request.command;
    request.set(command, "includeBlob", "N");
    request.child_element(command, "DocId", doc_id);
    request.child_element(command, "Lock", check_out ? "Y" : "N");
    request.child_element(command, "DocVersion", version);
    CString response = cdr::Socket::send_commands(request);
    cdr::DOM dom(response);
    return open_doc(dom, doc_id, check_out, version);
}

/**
 * Allows user to edit the current node, which represents a link to
 * another CDR document, or a value controlled by the schema for this document
 * type. Yes, it's an odd name for this method. Why it was chosen is lost
 * in the sands of time.
 *
 *  @param  ret_val - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::edit(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("edit");
    *ret_val = 1;

    try {

        // Make sure the user is logged on to the CDR.
        if (!cdr::Socket::logged_on()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Find the currently active document.
        _Document doc = cdr::get_app().GetActiveDocument();

        // Extract the control information from the document.
        DOMNode doc_element = doc.GetDocumentElement();
        CdrDocCtrlInfo ctrl_info;
        cdr::extract_ctl_info(doc_element, ctrl_info);
        CString doc_type = doc_element.GetNodeName();

        // Find the element with the current focus.
        ::Selection selection = cdr::get_app().GetSelection();
        CString elem_name = selection.GetContainerName();

        // See if we have a valid-values set for this element.
        const cdr::StringList* valid_values = get_schema_valid_values(
            doc_type,
            elem_name
        );
        if (valid_values) {
            CSchemaPicklist picklist(valid_values, L"", elem_name);
            if (picklist.DoModal() == IDOK)
                *ret_val = 0;
            return S_OK;
        }

        // Check for custom flavors of this command.
        CEditElement::Type edit_type = CEditElement::NORMAL;
        if (doc_type == L"Person") {
            if (elem_name  == L"OrganizationLocation") {
                if (selection.GetIsParentElement(L"OtherPracticeLocation"))
                    edit_type = CEditElement::ORG_LOCATION;
            }
            else if (elem_name == L"FamilialCancerSyndrome")
                edit_type = CEditElement::GP_SYNDROME;
        }

        // Most of the real work is done inside this call.
        CEditElement edit_dialog(doc_type, elem_name, edit_type);
        if (edit_dialog.DoModal() == IDOK)
            *ret_val = 0;
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error from edit command.");
    }
    return S_OK;
}

/**
 * Provide GUI interface for editing the comment attribute of the current node.
 *
 *  @param read_only - if VARIANT_TRUE just show the user the comment string
 *                    but don't let her edit it.
 */
STDMETHODIMP CCommands::editComment(VARIANT_BOOL readOnly) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("editComment");
    BOOL ro(readOnly);
    ::CCommentDialog dialog(ro);
    dialog.DoModal();

    return S_OK;
}

/*
 * Support for fetching information from the CDR web server.  Allows
 * us to implement simpler enhancements which would otherwise require
 * a rebuild of the CDR server.
 *
 * Called by the `objectFromUrl()` function in the JavaScript macro
 * file, but that function is currently unused. Leaving this is place
 * anyway for how, as it seems generally useful.
 *
 *  @param response_ - return value for string fetched from server
 */
STDMETHODIMP CCommands::fetchFromUrl(const BSTR* url_, BSTR* response_) {

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("fetchFromUrl");
    CString url(*url_);
    CString response;
    try {
        response = cdr::fetch_from_url(url);
    }
    catch (...) {
        ::AfxMessageBox(L"Unable to open " + url);
        response = L"";
    }
    response.SetSysString(response_);

    return S_OK;
}

/**
 * Fetch the PDQBoardMemberInfo document ID for the current Person document.
 *
 *  @param person_id - string containing the CDR ID of the active Person doc
 *  @param board_member_id - return string for the linked document
 */
STDMETHODIMP CCommands::getBoardMemberId(const BSTR* person_id,
                                         BSTR* board_member_id) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getBoardMemberId");
    CString id(*person_id);
    try {
        cdr::CommandSet request("CdrReport");
        auto command = request.command;
        request.child_element(command, "ReportName", "Board Member");
        auto params = request.child_element(command, "ReportParams");
        auto param = request.child_element(params, "ReportParam");
        request.set(param, "Name", "PersonId");
        request.set(param, "Value", id);
        CString response_xml = cdr::Socket::send_commands(request);
        cdr::DOM dom(response_xml);
        CString member_id = dom.get_text(dom.find("//BoardMember"));
        if (member_id.IsEmpty())
            cdr::show_errors(dom);
        member_id.SetSysString(board_member_id);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }

    return S_OK;
}

/**
 * Fetch the IDs of the term name documents associated with this concept doc.
 *
 *  @param concept_id    - string containing the CDR ID for the active
 *                         GlossaryTermConcept document
 *  @param term_name_ids - string of term name document IDs, space delimited
 */
STDMETHODIMP CCommands::getGlossaryTermNameIds(const BSTR* concept_id,
                                               BSTR* term_name_ids) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getGlossaryTermNameIds");
    CString id(*concept_id);
    CString ids;
    try {
        cdr::CommandSet request("CdrReport");
        auto command = request.command;
        request.child_element(command, "ReportName", "Glossary Term Names");
        auto params = request.child_element(command, "ReportParams");
        auto param = request.child_element(params, "ReportParam");
        request.set(param, "Name", "ConceptId");
        request.set(param, "Value", id);
        CString response_xml = cdr::Socket::send_commands(request);
        cdr::DOM dom(response_xml);
        if (!cdr::show_errors(dom)) {
            auto nodes = dom.find_all("//GlossaryTermName");
            CString sep;
            for (auto& node : nodes) {
                ids += sep + dom.get(node, "ref");
                sep = L" ";
            }
        }
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    ids.SetSysString(term_name_ids);
    return S_OK;
}

/**
 * Fetch the term names associated with the current glossary concept doc.
 *
 *  @param concept_id - string containing the CDR ID for the active
 *                     GlossaryTermConcept document
 *  @param term_names - string returned to the caller showing all of the
 *                     term names linked to this concept document
 */
STDMETHODIMP CCommands::getGlossaryTermNames(const BSTR* concept_id,
                                             BSTR* term_names) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getGlossaryTermNames");
    CString id(*concept_id);
    CString names;
    try {
        cdr::CommandSet request("CdrReport");
        auto command = request.command;
        request.child_element(command, "ReportName", "Glossary Term Names");
        auto params = request.child_element(command, "ReportParams");
        auto param = request.child_element(params, "ReportParam");
        request.set(param, "Name", "ConceptId");
        request.set(param, "Value", id);
        CString response_xml = cdr::Socket::send_commands(request);
        cdr::DOM dom(response_xml);
        if (!cdr::show_errors(dom)) {
            auto nodes = dom.find_all("//GlossaryTermName");
            CString sep(L"    ");
            for (auto& node : nodes) {
                names += sep + dom.get_text(node);
                sep = L"\n    ";
            }
        }
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    names.SetSysString(term_names);
    return S_OK;
}

/**
 * String property for the current CDR server's host name.
 *
 *  @param ret_val - address where the return string is passed back
 */
STDMETHODIMP CCommands::get_hostname(BSTR *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("get_hostname");
    CString hostname = cdr::Socket::get_host_name();
    hostname.SetSysString(ret_val);

    return S_OK;
}

/**
 * Provide information about the next validation error.
 *
 *  @param val_error - string with location and error message
 *                    delimited by '|'
 */
STDMETHODIMP CCommands::getNextValidationError(BSTR* val_error) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getNextValidationError");
    CString result;
    _Document doc = cdr::get_app().GetActiveDocument();
    if (!doc) {
        result = L"0|No document is currently active";
        result.SetSysString(val_error);
        return S_OK;
    }
    CString path = get_full_doc_path(&doc);
    cdr::debug_log("looking up next validation error for " + path);
    if (path.IsEmpty()) {
        result = L"0|No validation results available";
        result.SetSysString(val_error);
        return S_OK;
    }
    cdr::ValidationErrorSets::iterator iter =
        cdr::validation_error_sets.find(path);
    if (iter == cdr::validation_error_sets.end()) {
        result = L"0|No validation results available";
        result.SetSysString(val_error);
        return S_OK;
    }
    cdr::ValidationErrors* errors = iter->second;
    if (errors->errors.size() < 1) {
        result = L"0|No validation errors found";
        result.SetSysString(val_error);
        return S_OK;
    }
    if (errors->current_error >= errors->errors.size()) {
        result = L"0|No more validation errors found";
        result.SetSysString(val_error);
        return S_OK;
    }
    const cdr::ValidationError* error = errors->get_next_error();
    if (!error) {
        result = L"0|No more validation errors found";
        result.SetSysString(val_error);
        return S_OK;
    }
    CString eid = error->eid;
    if (eid.IsEmpty())
        eid = L"0";
    result = eid + L"|" + error->message;
    if (!error->elevel.IsEmpty())
        result += L" (" + error->elevel + L")";
    result.SetSysString(val_error);
    return S_OK;
}

/**
 * Insert a SpecificPostalAddresss element into the active Person document.
 *
 * Pulls in address information from the organization location block
 * linked from the current selection and inserts it so the user can
 * overide some of that information. See Jira ticket OCECDR-119.
 *
 *  @param ret_val - pointer to the return value
 */
STDMETHODIMP CCommands::getOrgAddress(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("getOrgAddress");
    // Initial pessimism.
    *ret_val = 1;

    try {

        // Make sure the user is logged on to the CDR.
        if (!cdr::Socket::logged_on()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Find the LeadOrgPersonnel element location.
        ::Range op_loc = cdr::get_elem_range(L"OtherPracticeLocation");
        if (!op_loc) {
            ::AfxMessageBox(L"OtherPracticeLocation for "
                            L"current location not found");
            return S_OK;
        }

        // Find the adddress fragment link.
        ::DOMElement op_elem = op_loc.GetContainerNode();
        if (!op_elem || op_elem.GetNodeName() != L"OtherPracticeLocation")
        {
            ::AfxMessageBox(L"Unable to find OtherPracticeLocation "
                            L"element");
            return S_OK;
        }
        ::DOMNodeList node_list =
            op_elem.getElementsByTagName(L"OrganizationLocation");
        if (node_list.GetLength() < 1) {
            ::AfxMessageBox(L"Unable to find OrganizationLocation element");

            return S_OK;
        }
        ::DOMElement org_loc_elem = node_list.item(0);
        CString addr_link = org_loc_elem.getAttribute(L"cdr:ref");
        if (addr_link.IsEmpty()) {
            ::AfxMessageBox(L"Missing or empty cdr:ref attribute "
                            L"for address link");

            return S_OK;
        }

        // Break the link into its two parts.
        int delim_pos = addr_link.Find(L"#");
        if (delim_pos < 1 || delim_pos == addr_link.GetLength() - 1) {
            ::AfxMessageBox(L"Malformed fragment link: " + addr_link);
            return S_OK;
        }
        CString doc_id = addr_link.Left(delim_pos);
        CString frag_id = addr_link.Mid(delim_pos + 1);

        // Ask the server for the full address.
        cdr::CommandSet request{"CdrFilter"};
        auto command = request.command;
        auto filter_element = request.child_element(command, "Filter");
        request.set(filter_element, "Name", "Organization Address Fragment");
        auto parms = request.child_element(command, "Parms");
        auto parm = request.child_element(parms, "Parm");
        request.child_element(parm, "Name", "fragId");
        request.child_element(parm, "Value", frag_id);
        auto document_element = request.child_element(command, "Document");
        request.set(document_element, "href", doc_id);

        // Submit the request to the CDR server.
        CWaitCursor wc;
        CString response_xml = cdr::Socket::send_commands(request);

        // Extract the address elements.
        cdr::DOM response{response_xml};
        CString doc_xml = response.get_text(response.find("//Document"));
        if (doc_xml.IsEmpty()) {
            if (!cdr::show_errors(response))
                ::AfxMessageBox(L"Unknown failure from filter request");
            return S_OK;
        }
        cdr::DOM addr_elems{doc_xml};
        auto postal_address = addr_elems.find("PostalAddress");
        if (!postal_address) {
            ::AfxMessageBox(L"PostalAddress not found");
            return S_OK;
        }
        auto children = addr_elems.find_all("*", postal_address);
        CString address_type = addr_elems.get(postal_address, "AddressType");
        if (address_type.IsEmpty())
            address_type = L"US";

        // Create and populate a new DOM object.
        cdr::DOM dom{"wrapper"};
        auto wrapper = dom.get_root();
        dom.set(wrapper, "xmlns:cdr", "cips.nci.nih.gov/cdr");
        CString tag = L"SpecificPostalAddress";
        auto specific_postal_address = dom.child_element(wrapper, tag);
        dom.set(specific_postal_address, "AddressType", address_type);
        for (auto& child : children)
            dom.append(specific_postal_address, child);

        // The reason we enclosed the new SpecificPostalAddress element
        // in a wrapper element is that we needed to attach the namespace
        // declaration to that wrapper so we can pull out the block we
        // really want without the namespace declaration. The problem is
        // that the DOM implementation we're using understands namespaces
        // but XMetaL's DOM API thinks xmlns:cdr="..." is just another
        // attribute, and won't let us paste in the XML fragment string
        // with that "attribute" because the DTD it's using doesn't allow
        // it. So we have to use a regular expression to pull out what we
        // want. Not ideal, but it's pretty safe, as the regular expression
        // isn't doing anything super tricky.
        std::wstring s{dom.get_xml().GetString()};
        std::wregex e{L"<SpecificPostalAddress.+</SpecificPostalAddress>"};
        std::wsmatch m;
        if (!std::regex_search(s, m, e)) {
            ::AfxMessageBox(L"Internal failure for " + tag);
            return S_OK;
        }
        CString fragment{m[0].str().c_str()};

        // Find the proper location for the address.
        ::Range location = cdr::find_or_create_child(op_loc, tag);
        if (!location) {
            ::AfxMessageBox(L"Failure creating " + tag + L" element");
            return S_OK;
        }

        // Plug in our own data.
        location.SelectElement();
        location.Select();
        if (!location.GetCanPaste(fragment, FALSE))
            ::AfxMessageBox(L"Unable to insert " + fragment);
        else {
            location.PasteString(fragment);
            *ret_val = 0;
        }

    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error retrieving contact address info");
    }

    return S_OK;
}

/**
 * Get the patient document ID for the summary matching this HP summary.
 *
 *  @param hp_doc_id - string for the health profession summary ID
 *  @param patient_doc_id - string for the return value
 */
STDMETHODIMP CCommands::getPatientDocId(const BSTR* hp_doc_id,
                                        BSTR* patient_doc_id) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getPatientDocId");
    CString id(*hp_doc_id);

    try {
        cdr::CommandSet request("CdrReport");
        auto command = request.command;
        request.child_element(command, "ReportName", "Patient Summary");
        auto params = request.child_element(command, "ReportParams");
        auto param = request.child_element(params, "ReportParam");
        request.set(param, "Name", "HPSummary");
        request.set(param, "Value", id);
        CString response_xml = cdr::Socket::send_commands(request);
        cdr::DOM response_dom(response_xml);
        auto node = response_dom.find("//PatientSummary");
        if (node) {
            CString patient_id = response_dom.get_text(node);
            patient_id.SetSysString(patient_doc_id);
        }
        else
            cdr::show_errors(response_dom);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error retrieving patient ID");
    }

    return S_OK;
}

/*
 * Count the non-markup characters in the current selection.
 *
 *  @param  ret_val - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::get_selectionCharacterCount(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    ::Selection selection = cdr::get_app().GetSelection();
    CString characters = selection.GetText();
    int n = 0;
    wchar_t q = L'\0';
    bool in_tag = false;
    for (int i = 0; i < characters.GetLength(); ++i) {
        wchar_t c = characters[i];
        if (in_tag) {
            if (q) {
                if (c == q)
                    q = L'\0';
            }
            else if (c == L'>')
                in_tag = false;
            else if (c == L'"' || c == L'\'')
                q = c;
        }
        else if (c == L'<')
            in_tag = true;
        else
            ++n;
    }
    *ret_val = n;

    return S_OK;
}

/**
 * Property for the current login's session ID string.
 *
 *  @param ret_val - pointer to the returned string value
 */
STDMETHODIMP CCommands::get_session(BSTR *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("get_session");
    CString session = cdr::Socket::get_session_string();
    session.SetSysString(ret_val);

    return S_OK;
}

/**
 * Find the CDR ID of the current English summary's translation.
 *
 *  @param original_id      - string containing the CDR ID of the active doc
 *  @param translated_doc_id - return string for the Spanish summary document
 */
STDMETHODIMP CCommands::getTranslatedDocId(const BSTR* original_id,
                                           BSTR* translated_doc_id) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("getTranslatedDocId");
    _Document doc = cdr::get_app().GetActiveDocument();
    DOMNode doc_element = doc.GetDocumentElement();
    CString doc_type = doc_element.GetNodeName();
    CString report_name = L"";
    CString param_name = L"";
    CString xpath = L"";
    CString translation_id;
    if (doc_type == L"Summary") {
        report_name = L"Translated Summary";
        param_name = L"EnglishSummary";
        xpath = L"//TranslatedSummary";
    }
    else if (doc_type == L"Media") {
        report_name = L"Translated Media Doc";
        param_name = L"EnglishMediaDoc";
        xpath = L"//TranslatedMediaDoc";
    }
    if (report_name.IsEmpty())
        ::AfxMessageBox(L"Unsupported document type " + doc_type);
    else {
        CString id(*original_id);
        try {
            cdr::CommandSet request("CdrReport");
            auto command = request.command;
            request.child_element(command, "ReportName", report_name);
            auto params = request.child_element(command, "ReportParams");
            auto param = request.child_element(params, "ReportParam");
            request.set(param, "Name", param_name);
            request.set(param, "Value", id);
            CString response_xml = cdr::Socket::send_commands(request);
            cdr::DOM response_dom(response_xml);
            auto node = response_dom.find(xpath);
            if (node)
                translation_id = response_dom.get_text(node);
            else
                cdr::show_errors(response_dom);
        }
        catch (::CException* e) {
            e->ReportError();
            e->Delete();
        }
        catch (const wchar_t* e) {
            ::AfxMessageBox(e);
        }
        catch (...) {
            ::AfxMessageBox(L"Unexpected error retrieving patient ID");
        }
    }
    translation_id.SetSysString(translated_doc_id);

    return S_OK;
}

/**
 * String property for the current user's CDR account name.
 *
 *  @param ret_val - pointer for return value
 */
STDMETHODIMP CCommands::get_username(BSTR *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("get_username");
    username.SetSysString(ret_val);

    return S_OK;
}

/**
 * String property for the client user directory.
 *
 *  @param ret_val - pointer for return value
 */
STDMETHODIMP CCommands::get_userPath(BSTR* ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("get_userPath");
    CString user_path = cdr::get_user_path();
    user_path.SetSysString(ret_val);

    return S_OK;
}

/**
 * Launch the dialog box for glossifying the current document.
 *
 *  @param dig        - flag indicating whether we should recurse, looking
 *                      for top-level summary sections wrapped in Insertion
 *                      or Deletion elements
 *  @param dictionary - optional string narrowing the scope to terms for
 *                      a single dictionary
 *  @param audience   - optional string narrowing the scope to terms for
 *                      a single audience
 */
STDMETHODIMP CCommands::glossify(VARIANT_BOOL dig, const BSTR* dictionary,
                                 const BSTR* audience) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    cdr::trace_log("glossify");
    CString dict(*dictionary);
    CString aud(*audience);
    if (dict.IsEmpty())
        cdr::debug_log(L"glossifying current document");
    else
        cdr::debug_log(L"bringing up the glossify dialog box");
    CGlossify glossify(dig != VARIANT_FALSE, dict, aud);
    glossify.DoModal();
    return S_OK;
}

/**
 * Execute the application associated with the active doc's attachment.
 *
 *  @param doc_id  - string with the CDR ID for the active document
 *  @param doc_ver - string with the optional version
 */
STDMETHODIMP CCommands::launchBlob(const BSTR* doc_id, const BSTR* doc_ver) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("launchBlob");
    CString id(*doc_id);
    CString ver(*doc_ver);
    CString filename;
    std::ios_base::openmode mode = std::ios_base::binary | std::ios_base::out;
    int int_id = cdr::get_doc_no(id);
    filename.Format(L"CDR%d", int_id);
    if (!ver.IsEmpty())
        filename += L"-" + ver;
    else
        ver = L"Current";

    // Construct the command to retrieve the document with its blob.
    try {
        cdr::CommandSet request("CdrGetDoc");
        auto command = request.command;
        request.set(command, "includeXml", "Y");
        request.set(command, "includeBlob", "Y");
        request.child_element(command, "DocId", id);
        request.child_element(command, "Lock", "N");
        request.child_element(command, "DocVersion", ver);
        CString response_xml = cdr::Socket::send_commands(request);

        // If parsing the response with the embedded blob puts too
        // much of a strain on resources, we may have to revert to
        // extracting the blob part by hand. Test to find out.
        cdr::DOM response_dom(response_xml);
        auto doc_element = response_dom.find("//CdrDoc");
        if (!doc_element) {
            cdr::show_errors(response_dom);
            return S_OK;
        }
        CString doc_type = response_dom.get(doc_element, "Type");
        auto blob_element = response_dom.find("//CdrDocBlob");
        if (!blob_element) {
            ::AfxMessageBox(L"Binary object not found");
            return S_OK;
        }
        auto xml_element = response_dom.find("CdrDocXml", doc_element);
        if (!xml_element) {
            ::AfxMessageBox(L"Missing document XML");
            return S_OK;
        }
        CString xml = response_dom.get_text(xml_element);
        CString doc_blob = response_dom.get_text(blob_element);
        auto blob_len = doc_blob.GetLength();

        // Use a local buffer type to ensure memory release even if an
        // exception occurs.
        struct Buf {
            Buf(size_t n) : buf(new char[n]) { memset(buf, 0, n); }
            ~Buf() { delete [] buf; }
            char* buf;
        };
        int dst_len = ::Base64DecodeGetRequiredLength(blob_len);
        Buf blob((size_t)dst_len);
        auto bytes = cdr::cstring_to_utf8(doc_blob).c_str();
        if (!::Base64Decode(bytes, blob_len, (BYTE*)blob.buf, &dst_len)) {
            ::AfxMessageBox(L"Failure decoding blob file");
            return S_OK;
        }


        // Save the file.
        CString path = cdr::get_user_path() + L"\\Cdr\\Media";
        ::CreateDirectory((LPCTSTR)path, NULL);
        path += L"\\" + filename;
        CString ext = get_blob_extension(xml, doc_type);
        if (ext.IsEmpty()) {
            ::AfxMessageBox(L"Unable to determine filename extension");
            return S_OK;
        }
        path += ext;
        std::string path_name = cdr::cstring_to_utf8(path);
        std::ofstream ofs(path_name.c_str(), mode);
        if (!ofs) {
            ::AfxMessageBox(L"Unable to write " + path);
            return S_OK;
        }
        ofs.write(blob.buf, dst_len);
        ofs.close();

        // Invoke the application registered by the user for this file type.
        ::ShellExecute(NULL, L"open", path, NULL, NULL, SW_SHOWNORMAL);
        return S_OK;
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error launching blob");
    }
    return S_OK;
}

/**
 * Ask the CDR server to log some troubleshooting information.
 *
 * Currently only invoked by the macros when the user invokes the
 * native XMetaL Save or Save As command (rather than CDR Save).
 *
 *  @param description - string to be logged
 *  @param ret_val - pointer to the COM return value
 */
STDMETHODIMP CCommands::logClientEvent(const BSTR* description, int* ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("logClientEvent");
    *ret_val = 0;
    CString desc(*description);
    try {
        cdr::CommandSet request("CdrLogClientEvent");
        request.child_element(request.command, "EventDescription", desc);
        CString response_xml = cdr::Socket::send_commands(request);
        cdr::DOM dom(response_xml);
        auto node = dom.find("//EventId");
        if (node) {
            wchar_t* end;
            *ret_val = (int)wcstol(dom.get_text(node).GetString(), &end, 10);
        }
        else
            cdr::show_errors(dom);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error launching blob");
    }

    return S_OK;
}

/**
 * Log out of the CDR server.
 *
 *  @param  ret_val - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::logoff(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("logoff");
    *ret_val = 1;

    // Show the user the list of documents she still has checked out.
    if (!username.IsEmpty()) {
        try {
            cdr::CommandSet request("CdrReport");
            auto command = request.command;
            request.child_element(command, "ReportName", "Locked Documents");
            auto params = request.child_element(command, "Params");
            auto param = request.child_element(params, "Param");
            request.set(param, "Name", "UserId");
            request.set(param, "Value", username);
            CString response_xml = cdr::Socket::send_commands(request);
            cdr::DOM dom(response_xml);
            CString ids;
            CString sep;
            auto nodes = dom.find_all("//ReportRow/DocId");
            for (auto& node : nodes) {
                ids += sep + dom.get_text(node);
                sep = L", ";
            }
            if (!ids.IsEmpty()) {
                CString warning = L"The following documents are still "
                                  L"locked by your CDR account:\n" + ids;
                ::AfxMessageBox(warning);
            }
        }
        catch (::CException* e) {
            e->ReportError();
            e->Delete();
        }
        catch (const wchar_t* e) {
            ::AfxMessageBox(e);
        }
        catch (...) {
            ::AfxMessageBox(L"Unexpected error launching blob");
        }
    }

    // Clear out the property for the logged-in user's name.
    username = L"";

    try {

        // Make sure the user is logged on to the CDR.
        if (!cdr::Socket::logged_on()) {
            return S_OK;
        }

        // Submit the logoff request to the server.
        cdr::CommandSet request("CdrLogoff");
        cdr::Socket::send_commands(request);
        *ret_val = 0;
    }
    catch (...) {}

    // Clear the session string so we'll know that we're no longer logged in.
    cdr::Socket::set_session_string("");
    return S_OK;
}

/**
 * Log on to the CDR.
 *
 * The name of this command is misleading. The user is already logged
 * into the CDR (that took place in the CDR client loader). We're
 * just registering the knowledge of that login with the DLL and doing
 * some miscellaneous prep work, like loading the CDR document type
 * information from the disk.
 *
 *  @param  ret_val - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::logon(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    // Start off assuming the worst.
    *ret_val = 1;
    cdr::trace_log("logon");

    try {

        // Make sure the user isn't already logged on.
        if (cdr::Socket::logged_on())
            return S_OK;

        // Make sure the client machine has the refresh utility installed.
        CString manifest_name = cdr::get_user_path() + L"\\CdrManifest.xml";
        if (_waccess((LPCTSTR)manifest_name, 0)) {
            ::AfxMessageBox(L"Client files missing");
            return S_OK;
        }

        // Get the user ID and session credentials. If the environment
        // variables aren't set, the user wants to run XMetaL in a
        // standalone session.
        username = L"";
        const char* sess_id = getenv("CDRSession");
        const char* user_id = getenv("CDRUser");
        if (!sess_id || !user_id)
            return S_OK;
        username = user_id;
        cdr::Socket::set_session_string(sess_id);

        // Identify who and where we are.
        setTitleBar();

        // Make the document directories if they aren't already there.
        CString cdr_path = cdr::get_user_path() + L"\\Cdr";
        CString ro_path  = cdr_path + L"\\ReadOnly";
        CString co_path  = cdr_path + L"\\Checkout";
        CString me_path  = cdr_path + L"\\Media";
        _wmkdir((LPCTSTR)cdr_path);
        _wmkdir((LPCTSTR)ro_path);
        _wmkdir((LPCTSTR)co_path);
        _wmkdir((LPCTSTR)me_path);

        // Get the document type information we need.
        load_doc_types();
        *ret_val = 0;
    }

    // Handle any extraordinary error conditions.
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* error) {
        ::AfxMessageBox(error);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected failure.");
    }
    return S_OK;
}

/**
 * Facilitate movement between comments in the active document.
 */
STDMETHODIMP CCommands::navigateComments(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("navigateComments");
    CFindComments *dialog = new CFindComments();
    dialog->Create(CFindComments::IDD);
    dialog->ShowWindow(SW_SHOW);

    return S_OK;
}

/**
 * Help the user move between the Insertion and Deletion elements.
 */
STDMETHODIMP CCommands::navigateMarkup(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("navigateMarkup");
    CFindMarkup *dialog = new CFindMarkup();
    dialog->Create(CFindMarkup::IDD);
    dialog->ShowWindow(SW_SHOW);

    return S_OK;
}

/**
 * Fetch and open the requested CDR document.
 *
 *  @param doc_id    - string for the CDR ID of the requested document
 *  @param doc_ver   - optional string for the version of the document to open
 *  @param check_out  - if VARIANT_TRUE then lock the document
 */
STDMETHODIMP CCommands::openCdrDoc(const BSTR* doc_id, const BSTR* doc_ver,
                                   VARIANT_BOOL check_out) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("openCdrDoc");
    CString id(*doc_id);
    CString ver(*doc_ver);
    BOOL co(check_out);
    try {
        doRetrieve(id, co, ver);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }

    return S_OK;
}

/**
 * Set link attribute and denormalized text for current linking element.
 *
 *  @param link - string containing the document ID for the link
 *  @param ret_val - pointer to the method's COM return value
 */
STDMETHODIMP CCommands::pasteDocLink(const BSTR* link, int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("pasteDocLink");
    *ret_val = 1;
    CString doc_link(*link);

    // Make sure the user is logged on to the CDR.
    if (!cdr::Socket::logged_on()) {
        ::AfxMessageBox(L"This session is not logged into the CDR");
        return S_OK;
    }

    // Find the currently active document.
    _Document doc = cdr::get_app().GetActiveDocument();

    // Get the current element and the doc type.
    DOMNode doc_element = doc.GetDocumentElement();
    CString doc_type = doc_element.GetNodeName();
    ::Range selection = cdr::get_app().GetSelection();
    ::DOMElement elem = selection.GetContainerNode();
    CString elem_name  = elem.GetNodeName();
    while (elem && elem.GetNodeType() != 1) // DOMElement
        elem = elem.GetParentNode();
    if (elem) {
        try {

            // Determine whether this is a cdr:ref or cdr:href link.
            ::DOMDocumentType dt = doc.GetDoctype();
            if (dt.GetHasAttribute(elem.GetNodeName(), L"cdr:href")) {

                // If this is a cdr:href link, this is all we need to do.
                elem.setAttribute(L"cdr:href", doc_link);
                *ret_val = 0;
                return S_OK;
            }

            // BZIssue::5172 - Add support for Target attribute.
            if (dt.GetHasAttribute(elem.GetNodeName(), L"Target")) {

                // If this is a Target link, this is all we need to do.
                elem.setAttribute(L"Target", doc_link);
                *ret_val = 0;
                return S_OK;
            }

            // Ask the server for the denormalized data.
            cdr::CommandSet request("CdrPasteLink");
            auto command = request.command;
            request.child_element(command, "SourceDocType", doc_type);
            request.child_element(command, "SourceElementType", elem_name);
            request.child_element(command, "TargetDocId", doc_link);
            CWaitCursor wc;
            CString response_xml = cdr::Socket::send_commands(request);
            cdr::DOM dom(response_xml);
            if (cdr::show_errors(dom))
                return S_OK;
            auto node = dom.find("//DenormalizedContent");
            if (!node) {
                ::AfxMessageBox(L"Server did not return denormalized content");
                return S_OK;
            }
            CString data = dom.get_text(node);
            if (data.IsEmpty()) {
                ::AfxMessageBox(L"Denormalized data empty");
                return S_OK;
            }

            // Plug in the link attribute.
            elem.setAttribute(L"cdr:ref", doc_link);

            // Clear out the existing children.
            ::DOMNode child = elem.GetFirstChild();
            while (child) {
                ::DOMNode next_child = child.GetNextSibling();
                ::DOMNode dummy = elem.removeChild(child);
                child = next_child;
            }

            // Pop in the new content.
            ::DOMText text_node = doc.createTextNode(data);
            ::DOMNode dummy = elem.appendChild(text_node);
        }
        catch (::CException* e) {
            e->ReportError();
            e->Delete();
        }
        catch (const wchar_t* e) {
            ::AfxMessageBox(e);
        }
        catch (...) {
            ::AfxMessageBox(L"Unexpected error pasting doc link");
        }

    }
    *ret_val = 0;

    return S_OK;
}

/**
 * Retrieves the CDR document represented by the document ID obtained
 * from the user.
 *
 *  @param  ret_val - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::retrieve(int *pRet) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("retrieve");
    *pRet = 1;
    try {

        // Working variables.
        CString err;
        RetrieveDialog dialog;

        // Make sure the user is logged on to the CDR.
        if (!cdr::Socket::logged_on())
            err = "This session is not logged into the CDR";
        // Ask the user which document to retrieve.
        if (err.IsEmpty()) {
            int rc = (int)dialog.DoModal();
            switch (rc) {
            case IDOK:
                if (doRetrieve(dialog.m_doc_id, dialog.m_check_out))
                    *pRet = 0;
                break;
            case IDCANCEL:
                break;
            case -1:
            default:
                err = L"Internal failure";
                break;
            }
        }

        // Give the user any bad news.
        if (!err.IsEmpty())
            ::AfxMessageBox(err);
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    return S_OK;
}

/**
 * Save the currently active document in the CDR repository.
 *
 *  @param  ret_val - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::save(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("save");
    *ret_val = 1;
    try {

        // Make sure the user is logged on to the CDR.
        if (!cdr::Socket::logged_on()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Get the currently active document.
        _Document doc = cdr::get_app().GetActiveDocument();
        if (!doc) {
            ::AfxMessageBox(L"There is no active document.");
            return S_OK;
        }

        // Extract control information from the document.
        DOMNode doc_element = doc.GetDocumentElement();
        CdrDocCtrlInfo ctrl_info;
        cdr::extract_ctl_info(doc_element, ctrl_info);
        CString doc_title = ctrl_info.doc_title;
        if (doc_title.IsEmpty())
            doc_title = L"Server will replace this dummy title";

        // Ask the user for options to be used for the operation.
        bool blob_possible = false;
        if (ctrl_info.doc_type == L"Media" ||
            ctrl_info.doc_type == L"SupplementaryInfo")
            blob_possible = true;
        CSaveDialog save_dialog(ctrl_info.ready_for_review, blob_possible);
        switch (save_dialog.DoModal()) {
        case IDOK:
        {
            CWaitCursor wc;
            clear_error_list();
            cdr::ValidationErrors* val_errors = NULL;

            // Build the save command.
            CString& doc_id = ctrl_info.doc_id;
            const char* unlock = save_dialog.m_checkIn ? "Y" : "N";
            CString& comment = save_dialog.m_comment;
            const char* tag = doc_id.IsEmpty() ? "CdrAddDoc" : "CdrRepDoc";
            cdr::CommandSet request(tag);
            auto command = request.command;
            request.child_element(command, "CheckIn", unlock);
            if (save_dialog.m_create_version) {
                auto version = request.child_element(command, "Version", "Y");
                const char* pub = save_dialog.m_version_publishable ? "Y" : "N";
                request.set(version, "Publishable", pub);
            }
            else
                request.child_element(command, "Version", "N");
            const char* validate = save_dialog.m_validate ? "Y" : "N";
            auto val = request.child_element(command, "Validate", validate);
            request.set(val, "ErrorLocators", "Y");
            request.child_element(command, "Echo", "Y");
            if (!comment.IsEmpty())
                request.child_element(command, "Reason", comment);
            auto cdr_doc = request.child_element(command, "CdrDoc");
            request.set(cdr_doc, "Type", ctrl_info.doc_type);
            if (!ctrl_info.doc_id.IsEmpty())
                request.set(cdr_doc, "Id", ctrl_info.doc_id);
            auto ctl = request.child_element(cdr_doc, "CdrDocCtl");
            if (!ctrl_info.doc_id.IsEmpty())
                request.child_element(ctl, "DocId", ctrl_info.doc_id);
            request.child_element(ctl, "DocType", ctrl_info.doc_type);
            request.child_element(ctl, "DocTitle", ctrl_info.doc_title);
            if (save_dialog.m_doc_inactive)
                request.child_element(ctl, "DocActiveStatus", "I");
            char* review = save_dialog.m_ready_for_review ? "Y" : "N";
            request.child_element(ctl, "DocNeedsReview", review);
            if (!comment.IsEmpty())
                request.child_element(ctl, "DocComment", comment);

            // Handle blob if present.
            char* blob = nullptr;
            int blob_size = 0;
            CFile blob_file;
            CString blob_filename = save_dialog.m_blob_filename_string;
            if (!blob_filename.IsEmpty()) {
                UINT flags = CFile::modeRead | CFile::shareDenyNone;
                if (!blob_file.Open((LPCTSTR)blob_filename, flags)) {
                    CString msg = "Failure loading " + blob_filename;
                    ::AfxMessageBox(msg);
                    return S_OK;
                }
                blob_size = (int)blob_file.GetLength();
                if (ctrl_info.doc_type == L"Media") {
                    try {
                        // Harmless if blob isn't an image.
                        insert_image_dimensions(doc_element, blob_file);
                    }
                    catch (...) {
                        ::AfxMessageBox(L"Unable to set image dimensions");
                    }
                    try {
                        // Shouldn't be a problem if this isn't an audio file.
                        insert_audio_seconds(doc_element, blob_file);
                    }
                    catch (...) {
                        ::AfxMessageBox(L"Unable to set RunSeconds");
                    }
                }
            }

            // Add the XML for the document, now that it's been tweaked.
            CString original_xml = doc.GetXml();
            request.add_cdr_document(cdr_doc, original_xml);

            // Use a local buffer type to ensure memory release even if an
            // exception occurs.
            struct Buf {
                Buf(size_t n) : buf(new char[n]) { memset(buf, 0, n); }
                ~Buf() { delete [] buf; }
                char* buf;
            };
            Buf blob_buf(blob_size);
            if (blob_size > 0) {
                try {
                    get_blob_from_file(blob_buf.buf, blob_file, blob_size);
                }
                catch (::CException* e) {
                    CString msg;
                    msg.Format(L"Failure loading %s", blob_filename);
                    ::AfxMessageBox(msg);
                    e->ReportError();
                    e->Delete();
                    return S_OK;
                }
                catch (...) {
                    CString msg;
                    msg.Format(L"Unknown failure loading %s", blob_filename);
                    ::AfxMessageBox(msg);
                    return S_OK;
                }
            }

            // Encode the blob if we have one.
            int encoded_blob_size = 0;
            if (blob_size)
                encoded_blob_size = Base64EncodeGetRequiredLength(blob_size);
            Buf encoded_blob_buffer(encoded_blob_size + 1);
            if (encoded_blob_size) {
                int written = encoded_blob_size;
                const BYTE* source = (const BYTE*)blob_buf.buf;
                blob = encoded_blob_buffer.buf;
                BOOL ok = Base64Encode(source, blob_size, blob, &written);
                if (!ok) {
                    ::AfxMessageBox(L"failure encoding blob");
                    return S_OK;
                }
                char* name = "CdrDocBlob";
                request.child_element(cdr_doc, name, BLOB_PLACEHOLDER);
            }

            // Submit the save command to the server.
            CString loc_id = get_location_id();
            CTime start_time = CTime::GetCurrentTime();
            CString response = cdr::Socket::send_commands(request, blob);
            cdr::DOM response_dom(response);
            CTime end_time = CTime::GetCurrentTime();
            CTimeSpan elapsed_time = end_time - start_time;
            auto cdr_response = response_dom.find("CdrResponse");
            if (response_dom.get(cdr_response, "Status") != L"success") {
                if (!cdr::show_errors(response_dom)) {
                    cdr::debug_log(response);
                    ::AfxMessageBox(L"Failure without explanation");
                }
            }
            else {

                // Show the user any validation errors.
                *ret_val = 0;
                val_errors = new cdr::ValidationErrors(response_dom);
                *ret_val = (int)val_errors->errors.size();
                if (!*ret_val) {
                    if (save_dialog.m_validate) {
                        CPassedValidation dlg(ctrl_info.doc_id);
                        dlg.DoModal();
                    }
                    delete val_errors;
                    val_errors = nullptr;
                }
                auto id_node = response_dom.find("//DocId");
                if (!id_node) {
                    delete val_errors;
                    val_errors = nullptr;
                    ::AfxMessageBox(L"Unable to find document ID");
                }
                else {
                    CString doc_id = response_dom.get_text(id_node);
                    doc.Close(2); // 2=don't save changes.
                    CString msg = elapsed_time.Format(
                        L"Document stored successfully (elapsed: %M:%S)");
                    if (ctrl_info.doc_id.IsEmpty())
                        msg += L"\nIt is now checked out to you.\n"
                            L"Please check in when processing is complete.";
                    ::AfxMessageBox(msg, MB_ICONINFORMATION);
                    if (!save_dialog.m_checkIn) {
                        open_doc(response_dom, doc_id, true, L"Current");
                        doc = cdr::get_app().GetActiveDocument();
                        if (val_errors) {
                            CString path = get_full_doc_path(&doc);
                            cdr::validation_error_sets[path] = val_errors;
                        }
                        if (!loc_id.IsEmpty()) {
                            ::DOMNode elem = doc.GetDocumentElement();
                            if (!move_to_location_id(loc_id, elem))
                                ::AfxMessageBox(L"didn't find " + loc_id);
                        }
                    }
                    else {
                        delete val_errors;
                        val_errors = nullptr;
                        remove_doc(doc_id);
                    }
                }
            }
            break;
        }
        case IDCANCEL:
            break;
        }
    }
    catch (::COleDispatchException* ode) {
        CString msg;
        msg.Format(L"Dispatch Exception; error code: %lu\n"
                   L"From application: %s\n"
                   L"Description: %s", ode->m_wCode, ode->m_strSource,
                   ode->m_strDescription);
        ::AfxMessageBox(msg);
        ode->Delete();
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected exception encountered.");
    }
    return S_OK;
}

/**
 * Submits a search request (obtained from the user) to the CDR server
 * and allows the user to retrieve one of the documents found.
 *
 *  @param  ret_val - address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::search(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("search");
    *ret_val = 1;
    try {

        // Make sure the user is logged on to the CDR.
        if (!cdr::Socket::logged_on()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Make sure the document type names got loaded.
        if (doc_type_strings.empty()) {
            ::AfxMessageBox(L"Document type information missing");
            return S_OK;
        }

        // Put up the dialog window.
        CSearchDialog search_dialog(doc_type_strings);

        // All the heavy lifting is done in this call.
        int rc = (int)search_dialog.DoModal();

        // Cancel means we're done, even for success. :-)
        if (rc == IDCANCEL)
            *ret_val = 0;
        else
            ::AfxMessageBox(L"Internal error");
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected failure.");
    }

    return S_OK;
}

/**
 * Mark the XMetaL application window's title bar with our current tier.
 */
STDMETHODIMP CCommands::setTitleBar(void) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //cdr::trace_log("set_title_bar"); XXX too noisy; clutters the log
    CWnd* w = ::AfxGetMainWnd();
    if (w) {
        CString title;
        title.Format(L"CDR Editor (%s)", cdr::Socket::get_host_tier());
        w->SetWindowText(title);
    }

    return S_OK;
}

/**
 * Launch Internet Explorer (!) for a specific URL.
 *
 *  @param url  - string for the address the user has requested
 *  @param ret_val - pointer to the method's return value
 */
STDMETHODIMP CCommands::showPage(const BSTR* url,  int* ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("showPage");
    CString url_string(*url);
    *ret_val = cdr::show_page(url_string);
    return S_OK;
}

/**
 * Ask the CDR server to validate the currently active document.
 *
 *  @param  ret_val - address of value returned for Microsoft Automation
 *                 (-1 for failure, otherwise number of validation errors
 *                 and/or warnings found).
 */
STDMETHODIMP CCommands::validate(int *ret_val) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

    cdr::trace_log("validate");
    *ret_val = -1;

    // Find the currently active document.
    _Document doc = cdr::get_app().GetActiveDocument();

    // Extract the document's control information.
    DOMNode doc_element = doc.GetDocumentElement();
    CdrDocCtrlInfo ctrl_info;
    cdr::ValidationErrors* val_errors = NULL;
    cdr::extract_ctl_info(doc_element, ctrl_info);
    if (ctrl_info.doc_id.IsEmpty()) {
        ::AfxMessageBox(L"Document has never been saved");
        return S_OK;
    }

    try {

        // Make sure the user is logged on to the CDR.
        if (!cdr::Socket::logged_on()) {
            ::AfxMessageBox(L"This session is not logged into the CDR");
            return S_OK;
        }

        // Ask the user for options to be used during validation.
        CValidateDialog dlg;
        switch (dlg.DoModal()) {
        case IDOK:
        {
            CWaitCursor wc;

            clear_error_list();

            CString doc_type = doc_element.GetNodeName();

            // Dialog box ensures that at least one is true.
            CString validation_types;
            if (dlg.m_schema_validation) {
                if (dlg.m_link_validation)
                    validation_types = L"Schema Links";
                else
                    validation_types = L"Schema";
            }
            else
                validation_types = L"Links";

            // Figure out how to resolve Insertion/Deletion markup.
            CString filter_level = L"3";
            if (dlg.m_include_proposed_and_approved_markup)
                filter_level = L"1";
            else if (dlg.m_include_approved_markup)
                filter_level = L"2";

            // Build the validate command.
            cdr::CommandSet request("CdrValidateDoc");
            auto command = request.command;
            request.set(command, "DocType", doc_type);
            request.set(command, "ErrorLocators", "Y");
            request.set(command, "ValidationTypes", validation_types);
            request.set(command, "Id", ctrl_info.doc_id);
            auto cdr_doc = request.child_element(command, "CdrDoc");
            request.set(cdr_doc, "Type", doc_type);
            request.set(cdr_doc, "RevisionFilterLevel", filter_level);
            auto doc_ctl = request.child_element(cdr_doc, "CdrDocCtl");
            if (!ctrl_info.doc_id.IsEmpty())
                request.child_element(doc_ctl, "DocId", ctrl_info.doc_id);
            request.child_element(doc_ctl, "DocTitle", ctrl_info.doc_title);
            CString original_xml = doc.GetXml();
            request.add_cdr_document(cdr_doc, original_xml);

            // Submit the validate command to the server.
            CString response_xml = cdr::Socket::send_commands(request);
            cdr::DOM response_dom(response_xml);
            val_errors = new cdr::ValidationErrors(response_dom);
            *ret_val = (int)val_errors->errors.size();
            if (*ret_val) {
                CString path = get_full_doc_path(&doc);
                CString msg;
                msg.Format(L"saving %d errors for %s", *ret_val, path);
                cdr::debug_log(msg);
                cdr::validation_error_sets[path] = val_errors;
                CString version = L"Current";
                bool check_out = path.Find(L"Checkout") != -1;
                int ver_pos = path.Find(L"-V");
                if (ver_pos != -1) {
                    version = path.Mid(ver_pos + 2);
                    version = version.Left(version.GetLength() - 4);
                }
                doc.Close(2); // 2=don't save changes.
                open_doc(response_dom, ctrl_info.doc_id, check_out, version);
            }
            else {
                delete val_errors;
                val_errors = nullptr;
                CPassedValidation dlg(ctrl_info.doc_id);
                dlg.DoModal();
            }
            break;
        }
        case IDCANCEL:
            break;
        }
    }
    catch (::CException* e) {
        e->ReportError();
        e->Delete();
    }
    catch (const wchar_t* e) {
        ::AfxMessageBox(e);
    }
    catch (...) {
        ::AfxMessageBox(L"Unexpected error from validation command.");
    }
    return S_OK;
}

/*
 * Ask the CDR Server to find the values found at a specified
 * path in a specific CDR document.  Returns the list of values
 * in a single string, using the ASCII RS (record separator)
 * as delimiter between the values, since this control character
 * is not permitted in XML documents.  If it's possible to
 * return an array of strings from a COM object, I was unable
 * to find documentation for this feature.
 *
 * Not called from anywhere any more, but I'm keeping it because
 * it seems like useful general-purpose functionality.
 *
 *  @param doc_id  - CDR document ID string in canonical form
 *  @param path   - string for location in the document to search
 *  @param values - pointer to string for return value
 */
STDMETHODIMP CCommands::valuesForPath(const BSTR* doc_id, const BSTR* path,
                                      BSTR* values) {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cdr::trace_log("valuesForPath");
    CString RS = L"\x0E";
    CString id(*doc_id);
    CString p(*path);
    cdr::CommandSet request("CdrReport");
    auto command = request.command;
    request.child_element(command, "ReportName", "Values For Path");
    auto params = request.child_element(command, "ReportParams");
    auto param1 = request.child_element(params, "ReportParam");
    auto param2 = request.child_element(params, "ReportParam");
    request.set(param1, "Name", "DocId");
    request.set(param1, "Value", id);
    request.set(param2, "Name", "Path");
    request.set(param2, "Value", p);
    CString response_xml = cdr::Socket::send_commands(request);
    cdr::DOM dom(response_xml);
    auto nodes = dom.find_all("//Value");
    CString result = L"";
    CString sep = L"";
    for (auto& node : nodes) {
        result += sep + dom.get_text(node);
        sep = RS;
    }
    result.SetSysString(values);

    return S_OK;
}


//----------------------------------------------------------------------
//                       LOCAL SUPPORTING FUNCTIONS
//----------------------------------------------------------------------

/**
 * Empty the in-memory list of validation errors.
 *
 * Called by:
 *   CCommands::save()
 */
static void clear_error_list() {
    _Document doc = cdr::get_app().GetActiveDocument();
    if (doc) {
        CString path = get_full_doc_path(&doc);
        if (!path.IsEmpty()) {
            cdr::ValidationErrorSets::iterator iter =
                cdr::validation_error_sets.find(path);
            if (iter != cdr::validation_error_sets.end()) {
                delete iter->second;
                cdr::validation_error_sets.erase(iter);
            }
        }
    }
}

/**
 * Find out which file name extension belongs with this document's attachment.
 *
 * Called by:
 *   CCommands::launchBlob()
 *
 *  @param doc_xml  - string containing the document's serialized XML
 *  @param doc_type - string containing the document's type name
 *
 * Return:
 *   string (with leading period) for the attachment's file name if knowable,
 *   otherwise empty string
 */
static CString get_blob_extension(const CString& doc_xml,
                                  const CString& doc_type) {
    CString extension;
    cdr::DOM dom(doc_xml);
    if (doc_type == L"Media") {
        auto node = dom.find("//ImageEncoding");
        if (!node)
            node = dom.find("//VideoEncoding");
        if (!node)
            node = dom.find("//SoundEncoding");
        if (node)
            extension = L"." + dom.get_text(node);
    }
    else if (doc_type == L"SupplementaryInfo") {
        CString mime_type = dom.get_text(dom.find("MimeType"));
        if (mime_type == L"application/pdf")
            extension = L".pdf";
        else if (mime_type == L"application/msword")
            extension = L".doc";
        else if (mime_type == L"application/vnd.ms-excel")
            extension = L".xls";
        else if (mime_type ==
                 L"vnd.openxmlformats-officedocument.spreadsheetml.sheet")
            extension = L".xlsx";
        else if (mime_type == L"application/vnd.wordperfect")
            extension = L".wpd";
        else if (mime_type == L"text/html")
            extension = L".html";
        else if (mime_type == L"text/rtf")
            extension = L".rtf";
        else if (mime_type == L"text/plain")
            extension = L".txt";
        else if (mime_type == L"message/rfc822")
            extension = L".txt";
        else if (mime_type == L"image/jpeg")
            extension = L".jpg";
    }
    return extension.MakeLower();
}

/**
 * Load bytes for a document BLOB from the specified file.
 *
 * Called by:
 *   CCommands::save()
 *
 *  @param buf  - pointer to allocated byte buffer to be filled
 *  @param file - reference to object used to read the file's bytes
 *  @param len  - integer containing the number of bytes to be read
 */
static void get_blob_from_file(char* buf, CFile& file, int len) {
    int total_read = 0;
    while (total_read < len) {
        int bytes_read = file.Read(buf + total_read, len - total_read);
        if (bytes_read < 1)
            throw L"Failure reading from blob file";
        total_read += bytes_read;
    }
}

/**
 * Assemble the absolute path to a specific document's file on the disk.
 *
 * Called by:
 *   CCommands::getNextValidationError()
 *   CCommands::save()
 *   CCommands::validate()
 *   clear_error_list()
 *
 *  @param doc - pointer to the document of interest
 *
 * Return:
 *   string for the document's location on disk
 */
static CString get_full_doc_path(_Document* doc) {
    return doc->GetPath() + L"\\" + doc->GetName();
}

/**
 * Get the cdr:id attribute value for the current location.
 *
 * Recursively crawl up toward the document root until we find an
 * enclosing element with such an attribute. If there isn't such
 * an element, return an empty string.
 *
 * Called by:
 *   CCommands::save()
 *
 * Return:
 *   string for the location's nearest cdr:id attribute value
 */
static CString get_location_id() {

    ::Range selection = cdr::get_app().GetSelection();
    ::DOMElement elem = selection.GetContainerNode();
    while (elem) {
        if (elem.GetNodeType() == 1) { // DOMElement
            CString id = elem.getAttribute(L"cdr:id");
            if (!id.IsEmpty())
                return id;
        }
        elem = elem.GetParentNode();
    }
    return L"";
}

/**
 * Find the set of values valid for the current element.
 *
 * Called by:
 *   CCommands::edit()
 *
 *  @param doc_type - string for the name of the active document's type
 *  @param path    - identification of the currently selected element
 *
 * Return:
 *   pointer to a set of valid values if applicable, otherwise nullptr
 */
static cdr::StringList* get_schema_valid_values(const CString doc_type,
                                             const CString path)
{
    if (valid_value_sets.find(doc_type) == valid_value_sets.end())
        return nullptr;
    cdr::ValidValueSet& vv_set = valid_value_sets[doc_type];
    if (vv_set.find(path) == vv_set.end())
        return nullptr;
    return &vv_set[path];
}

/**
 * Examine an audio file to get its run time duration and record it.
 *
 * Called by:
 *   CCommands::save()
 *
 *  @param doc_element - reference to element in which the duration is set
 *  @param file       - reference to the object used to read the file's bytes
 */
static void insert_audio_seconds(::DOMNode& doc_element, CFile& file) {

    // Start by blanking out the existing value, to prevent leaving
    // invalid information in the event that we're unable to determine
    // the correct new information.  If the element is not already
    // present, we do nothing.
    cdr::debug_log("clearing out AudioSeconds");
    if (!replace_audio_seconds(doc_element, L""))
        return;

    int seconds = cdr::get_audio_seconds(file);
    if (seconds >= 0) {
        CString s;
        s.Format(L"%d", seconds);
        cdr::debug_log(L"setting AudioSeconds to " + s);
        replace_audio_seconds(doc_element, s);
    }
}

/**
 * Examine an image file to get its dimensions and record them.
 *
 * Called by:
 *   CCommands::save()
 *
 *  @param doc_element - reference to element in which the dimensions are set
 *  @param file       - reference to the object used to read the file's bytes
 */
static void insert_image_dimensions(::DOMNode& doc_element, CFile& file) {

    // Start by blanking out the existing values, to prevent leaving
    // invalid information in the event that we're unable to determine
    // the correct new information.  If the dimension elements are not
    // already present, we do nothing.
    if (!replace_image_dimensions(doc_element, L"", L""))
        return;

    cdr::ImageDimensions dim;
    if (cdr::get_image_dimensions(file, dim)) {
        CString height, width;
        height.Format(L"%ld", dim.height);
        width.Format(L"%ld", dim.width);
        replace_image_dimensions(doc_element, height, width);
    }

    // Restore file position for loading the entire blob.
    file.SeekToBegin();
}

/**
 * Determine whether the active document is a Spanish Summary document.
 *
 * Called by:
 *   CCommands::addGlossaryPhrase()
 *
 * Return:
 *   true iff the SummaryLanguage element has the text value "Spanish"
 */
static bool is_spanish_summary() {
    _Application app = cdr::get_app();
    ::_Document doc = app.GetActiveDocument();
    DOMNode doc_element = doc.GetDocumentElement();
    CString doc_type = doc_element.GetNodeName();
    if (doc_type == L"Summary") {
        ::DOMNode c = doc_element.GetFirstChild();
        while (c) {
            if (c.GetNodeName() == L"SummaryMetaData") {
                ::DOMNode gc = c.GetFirstChild();
                while (gc) {
                    if (gc.GetNodeName() == L"SummaryLanguage") {
                        CString value = cdr::extract_element_text(gc);
                        if (value == L"Spanish")
                            return true;
                    }
                    gc = gc.GetNextSibling();
                }
            }
            c = c.GetNextSibling();
        }
    }
    return false;
}

/**
 * Load document type information from the file system.
 *
 * Called by:
 *   CCommands::logon()
 *
 * Populates file-scope collections doc_type_strings and valid_value_sets.
 *
 * Throws a string-based exception if reading or parsing fails.
 */
static void load_doc_types() {

    // Use a local buffer type to ensure memory release even if an
    // exception occurs.
    struct Buf {
        Buf(size_t n) : buf(new char[n]) { memset(buf, 0, n); }
        ~Buf() { delete [] buf; }
        char* buf;
    };
    CFile file;
    CString path = cdr::get_user_path() + L"\\CdrDocTypes.xml";
    file.Open((LPCTSTR)path, CFile::modeRead);
    int n_bytes = (int)file.GetLength();
    if (n_bytes <= 0)
        throw L"Missing document type information";

    Buf b((size_t)n_bytes);
    int total_read = 0;
    while (total_read < n_bytes) {
        int bytes_read = file.Read(b.buf + total_read, n_bytes - total_read);
        if (bytes_read < 1)
            throw L"Failure reading from CdrDocTypes.xml";
        total_read += bytes_read;
    }
    CString info = cdr::utf8_to_cstring(b.buf);

    // Populate these maps.
    doc_type_strings.clear();
    valid_value_sets.clear();
    doc_type_strings.push_back(L"Any Type");

    // Loop through the document types.
    cdr::DOM dom(info);
    auto responses = dom.find_all("CdrGetDocTypeResp");
    for (auto& response : responses) {
        if (dom.get(response, "Format") == L"xml") {
            CString doc_type = dom.get(response, "Type");
            doc_type_strings.push_back(doc_type);
            cdr::ValidValueSet vv_set;
            auto enum_sets = dom.find_all("EnumSet", response);
            for (auto& enum_set : enum_sets) {
                CString path = dom.get(enum_set, "Node");
                if (vv_set.find(path) == vv_set.end()) {
                    cdr::StringList& values = vv_set[path] = cdr::StringList();
                    auto elements = dom.find_all("ValidValue", enum_set);
                    for (auto& vv : elements) {
                        CString value = dom.get_text(vv);
                        values.push_back(value);
                    }
                }
            }
            valid_value_sets[doc_type] = vv_set;
            cdr::StringSet names;
            CString path = L"LinkingElements/LinkingElement";
            auto elements = dom.find_all(path, response);
            for (auto& linking_element : elements) {
                CString name = dom.get_text(linking_element);
                if (!name.IsEmpty())
                    names.insert(name);
            }
            linking_elements[doc_type] = names;
        }
    }
}

/**
 * Restore the user's position after a document save.
 *
 * Invoked recursively by CCommands::save() crawling down from the top of
 * the document until we find the matching cdr:id representing where the
 * user's cursor was prior to the save. We have to do it like this, because
 * our DTD doesn't use "ID" as the type of the cdr:id attribute.
 *
 * Note that we have to set the m_bAutoRelease flag of the DOMElement object
 * to which we assign the DOMNode, so XMetaL's DOM implementation doesn't blow
 * up with a complaint about a "pure virtual function."
 *
 * See https://tracker.nci.nih.gov/browse/OCECDR-4933.
 *
 *  @param id    - string value of the cdr:id attribute for the saved position
 *  @param node  - candidate node to examine (recursively)
 *
 * Return:
 *   true if we found the target location and moved there; otherwise false
 */
static bool move_to_location_id(const CString& id, ::DOMNode& node) {
    if (node.GetNodeType() == 1) { // ELEMENT
        ::DOMElement elem = node;
        elem.m_bAutoRelease = 0; // Avoid "pure virtual function" exception!!!
        CString value = elem.getAttribute(L"cdr:id");
        if (value == id) {
            ::Selection selection = cdr::get_app().GetSelection();
            selection.SelectNodeContents(node);
            selection.MoveLeft(0);
            return true;
        }
        ::DOMNode child = node.GetFirstChild();
        while (child) {
            if (move_to_location_id(id, child))
                return true;
            child = child.GetNextSibling();
        }
    }
    return false;
}

/**
 * Open a new window in XMetaL with a CDR document.
 *
 * Called by:
 *   CCommands::doRetrieve()
 *   CCommands::save()
 *   CCommands::validate()
 *
 *  @param response  - parsed response from the CDR server
 *  @param doc_id    - string containing the CDR ID of the retrieved document
 *  @param check_out - TRUE if the document was locked for editing
 *  @param version   - string with the version number (or "Current")
 */
static bool open_doc(cdr::DOM& response, const CString& doc_id, BOOL check_out,
                    const CString& version) {

    // Create local variables needed by the method.
    _Application app = cdr::get_app();
    Documents docs = app.GetDocuments();
    unsigned int doc_no = cdr::get_doc_no(doc_id);
    CString err;
    CString blocked = L"N";
    CString doc_type;
    CString doc_path;
    CString retrieved_doc_title;
    CString doc_title;
    CString cdr_path = cdr::get_user_path() + L"\\Cdr";

    // Find out if the document has been marked ReadyForReview.
    CString ready_for_review = L"N";
    auto rr_element = response.find("//ReadyForReview");
    if (rr_element && response.get_text(rr_element) == L"Y")
        ready_for_review = L"Y";

    // Build up path string.
    CString ver_part = L"";
    if (version != L"Current")
        ver_part.Format(L"-V%s", version);
    doc_path.Format(L"%s\\%s\\CDR%u%s.xml",
                   (LPCTSTR)cdr_path,
                   check_out ? L"Checkout" : L"ReadOnly",
                   doc_no,
                   (LPCTSTR)ver_part);

    // See if we got the document we asked for.
    auto cdr_doc_block = response.find("//CdrDoc");
    if (!cdr_doc_block) {

        // Log the response so we can examine it.
        char name[1024];
        time_t now = time(NULL);
        sprintf(name, "response-%lld.xml", (long long)now);
        std::ofstream response_stream(name, std::ios::binary);
        if (response_stream)
            response_stream << cdr::cstring_to_utf8(response.get_xml()).c_str();
        err = response.get_text(response.find("//Errors/Err"));
        if (err.IsEmpty())
            err = L"Unknown failure retrieving document from CDR";
    }
    else {

        doc_type = response.get(cdr_doc_block, "Type");
        auto doc_control = response.find("CdrDocCtl", cdr_doc_block);
        auto title_element = response.find("DocTitle", doc_control);
        if (title_element) {
            doc_title = response.get_text(title_element);
            CString title_start = doc_title.Left(15); // OCECDR-3914
            if (title_start.GetLength() < doc_title.GetLength())
                title_start += L'\x2026';
            retrieved_doc_title.Format(L"CDR%u%s%s - %s", doc_no, ver_part,
                                     check_out ? L"" : L" [RO]", title_start);
        }
        auto status_element = response.find("DocActiveStatus", doc_control);
        if (response.get_text(status_element) == L"I")
            blocked = L"Y";
    }

    // Extract the DocXml.
    CString doc_xml;
    if (err.IsEmpty() && doc_type.IsEmpty())
        err = L"Missing Type attribute in CdrDoc element";
    if (err.IsEmpty()) {
        auto xml_elem = response.find("CdrDocXml", cdr_doc_block);
        doc_xml = response.get_text(xml_elem);
    }

    // Write out the document to the file system.
    if (!doc_xml.IsEmpty()) {
        std::string path_name = cdr::cstring_to_utf8(doc_path);
        std::ofstream xml_stream(path_name.c_str(), std::ios::binary);
        if (!xml_stream)
            err.Format(L"Can't write xml document at %s", (LPCTSTR)doc_path);
        else {

            // Do some massaging (primarily insertion of the control block).
            try {
                cdr::DOM dom(doc_xml.Trim());
                auto root = dom.get_root();
                if (!check_out)
                    dom.set(root, "readonly", "yes");
                CString tag = dom.get_node_name(root);
                if (tag != doc_type) {
                    CString msg;
                    msg.Format(L"Got %s doc instead of %s", tag, doc_type);
                    ::AfxMessageBox(msg);
                    return false;
                }
                auto doc_ctl = dom.element("CdrDocCtl");
                dom.set(doc_ctl, "readyForReview", ready_for_review);
                dom.set(doc_ctl, "blocked", blocked);
                dom.child_element(doc_ctl, "DocId", doc_id);
                dom.child_element(doc_ctl, "DocTitle", doc_title);
                dom.insert(root, doc_ctl, dom.find("*", root));
                CString xml_decl = L"<?xml version=\"1.0\"?>\n";
                CString dtd;
                CString dt(doc_type);
                dtd.Format(L"<!DOCTYPE %s SYSTEM '%s.dtd'>\n", dt, dt);
                CString new_xml = xml_decl + dtd + dom.get_xml(root);
                xml_stream << cdr::cstring_to_utf8(new_xml).c_str();
            }
            catch (::CException* e) {
                e->ReportError();
                e->Delete();
                return false;
            }
            catch (const wchar_t* error) {
                ::AfxMessageBox(error);
                return false;
            }
            catch (...) {
                ::AfxMessageBox(L"Failure preparing document for saving");
                return false;
            }
        }
    }

    // Show any bad news to the user.
    if (!err.IsEmpty()) {
        ::AfxMessageBox(err);
    }
    else {

        // Open the document and set its title bar string.
        try {
            _Document doc = docs.Open((LPCTSTR)doc_path, 1);
            if (doc) {
                doc.SetTitle(retrieved_doc_title);
                return true;
            }
        }
        catch (::COleDispatchException* ode) {
            CString msg;
            msg.Format(L"Dispatch Exception; error code: %lu\n"
                       L"From application: %s\nDescription: %s",
                       ode->m_wCode, ode->m_strSource, ode->m_strDescription);
            ::AfxMessageBox(msg);
            ode->Delete();
        }
        catch (::CException* e) {
            e->ReportError();
            e->Delete();
        }
        catch (const wchar_t* e) {
            ::AfxMessageBox(e);
        }
        catch (...) {
            ::AfxMessageBox(L"Unexpected exception retrieving document");
        }
    }
    cdr::debug_log(L"leaving open_doc() in defeat");
    return false;
}

/**
 * Delete a CDR document from the file system.
 *
 * We only do this for locked documents which are being checked back in.
 *
 * Called by:
 *   CCommands::checkIn()
 *   CCommands::save()
 *
 *  @param doc_id - string containing the CDR ID for the document to be
 *                 removed
 */
static void remove_doc(const CString& doc_id) {
    unsigned int doc_no = cdr::get_doc_no(doc_id);
    CString cdr_path = cdr::get_user_path() + L"\\Cdr";
    CString doc_path;
    doc_path.Format(L"%s\\Checkout\\CDR%u.xml", (LPCTSTR)cdr_path, doc_no);
    try {
        CFile::Remove((LPCTSTR)doc_path);
    }
    catch (...) {}
}

/**
 * Set the duration of a SoundData block.
 *
 * Called by:
 *   insert_audio_seconds()
 *
 *  @param doc_element - reference to node whose duration we set
 *  @param seconds    - string containing the number of runtime seconds
 */
static bool replace_audio_seconds(::DOMNode& doc_element, CString seconds) {
    ::DOMElement& elem = (::DOMElement&)doc_element;
    ::DOMNodeList node_list = elem.getElementsByTagName(L"SoundData");
    if (node_list == 0 || node_list.GetLength() < 1)
        return false;
    ::DOMElement sound_data = node_list.item(0);
    ::DOMElement child = sound_data.GetFirstChild();
    while (child != 0) {
        if (child.GetNodeName() == L"RunSeconds") {
            cdr::replace_element_content(child, seconds);
            cdr::debug_log("found and replaced RunSeconds value");
            return true;
        }
        child = child.GetNextSibling();
    }
    cdr::debug_log("couldn't find RunSeconds element");
    return false;
}

/**
 * Set height and width for an image element.
 *
 * Called by:
 *   insert_image_dimensions()
 *
 *  @param doc_element - reference to node whose dimensions we set
 *  @param height      - string for the height of the image
 *  @param width       - string for the width of the image
 */
static bool replace_image_dimensions(::DOMNode& doc_element,
                                   CString height, CString width) {
    ::DOMElement& elem = (::DOMElement&)doc_element;
    ::DOMNodeList node_list = elem.getElementsByTagName(L"ImageDimensions");
    if (node_list == 0 || node_list.GetLength() < 1)
        return false;
    ::DOMElement dim_elem = node_list.item(0);
    ::DOMElement child = dim_elem.GetFirstChild();
    bool found_height = false, found_width = false;
    while (child != 0) {
        if (child.GetNodeName() == L"HeightPixels") {
            cdr::replace_element_content(child, height);
            found_height = true;
        }
        else if (child.GetNodeName() == L"WidthPixels") {
            cdr::replace_element_content(child, width);
            found_width = true;
        }
        child = child.GetNextSibling();
    }
    return found_height && found_width;
}
