/*
 * $Id: Commands.cpp,v 1.1 2000-10-16 22:29:27 bkline Exp $
 *
 * Implementation of CCdrApp and DLL registration.
 *
 * To do: rationalize error return codes for automation commands.
 *
 * $Log: not supported by cvs2svn $
 */

// Local headers.
#include "stdafx.h"
#include "Cdr.h"
#include "Commands.h"
#include "CdrUtil.h"
#include "LogonDialog.h"
#include "RetrieveDialog.h"
#include "SearchDialog.h"
#include "SaveDialog.h"
#include "ValidateDialog.h"
#include "EditElement.h"
#include "resource.h"

// System headers
#include <list>
#include <string>
#include <fstream>
#include <sstream>

// Prevent annoying warning from compiler about Microsoft's own bugs.
#pragma warning(disable : 4503)

// Local functions.
static void         getDocTypeStrings(CString& err);
static std::string& fixDoc(std::string& doc, const std::string& ctl);

// Local data.
static std::list<std::string> docTypeStrings;

/////////////////////////////////////////////////////////////////////////////
// This method was generated by a MSVC++ wizard.

STDMETHODIMP CCommands::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ICommands,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/**
 * Log on to the CDR.
 *
 *  @param  pRet    address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::logon(int *pRet)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try {

        // Make sure the user isn't already logged on.
		if (CdrSocket::loggedOn()) {
			::AfxMessageBox("This session is already logged into the CDR",
							MB_ICONEXCLAMATION);
			*pRet = 1;
			return S_OK;
		}

        // Get the user's CDR credentials.
		LogonDialog logonDialog;
		int rc = logonDialog.DoModal();
		switch (rc) {
		case IDOK:
			break;
		case IDCANCEL:
			*pRet = 2;
			return S_OK;
		case -1:
		default:
			::AfxMessageBox("Internal failure", MB_ICONEXCLAMATION);
			*pRet = 3;
			return S_OK;
		}

        // Create the logon command.
		std::string request = std::string("<CdrLogon><UserName>")
							+ (const char*)logonDialog.m_UserId 
							+ "</UserName><Password>"
							+ (const char*)logonDialog.m_Password
							+ "</Password></CdrLogon>";

        // Submit the command to the CDR server.
		std::string response = CdrSocket::sendCommand(request);
		if (!response.empty()) {
			TinyXmlParser p(response);
			CdrSocket::setSessionString(p.extract("SessionId"));
			if (!CdrSocket::loggedOn()) {
				std::string err = p.extract("Err");
				if (err.empty())
					err = "Unknown failure logging on to the CDR";
				::AfxMessageBox(err.c_str(), MB_ICONEXCLAMATION);
				*pRet = 4;
				return S_OK;
			}
			::AfxMessageBox("CDR Logon Successful");
			*pRet = 0;
			return S_OK;
		}
	}

    // Handle any extraordinary error conditions.
	catch (...) {
        ::AfxMessageBox("Unexpected exception encountered.");
        *pRet = 6;
    }
    *pRet = 5;
    return S_OK;
}

/**
 * Retrieves the CDR document represented by the document ID obtained
 * from the user.
 *
 *  @param  pRet    address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::retrieve(int *pRet)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try {

		// Working variables.
		CString err;
		RetrieveDialog retrieveDialog;

		// Make sure the user is logged on to the CDR.
		if (!CdrSocket::loggedOn())
			err = "This session is not logged into the CDR";

		// Ask the user which document to retrieve.
		if (err.IsEmpty()) {
			int rc = retrieveDialog.DoModal();
			switch (rc) {
			case IDOK:
				if (doRetrieve((const std::string)retrieveDialog.m_DocId))
					*pRet = 0;
				else
					*pRet = 2;
				break;
			case IDCANCEL:
				*pRet = 1;
				break;
			case -1:
			default:
				*pRet = 2;
				err = "Internal failure";
				break;
			}
		}

		// Give the user any bad news.
		if (!err.IsEmpty())
			::AfxMessageBox(err, MB_ICONEXCLAMATION);
	}
	catch (...) {
        ::AfxMessageBox("Unexpected exception encountered.");
        *pRet = 6;
    }
    return S_OK;
}

/**
 * Submits a search request (obtained from the user) to the CDR server
 * and allows the user to retrieve one of the documents found.
 *
 *  @param  pRet    address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::search(int *pRet)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try {

		// Working variables.
		CString err;

		// Make sure the user is logged on to the CDR.
		if (!CdrSocket::loggedOn())
			err = "This session is not logged into the CDR";

		// Put up the dialog window.
		if (err.IsEmpty() && docTypeStrings.empty())
			getDocTypeStrings(err);
		if (err.IsEmpty()) {
			CSearchDialog searchDialog(docTypeStrings);

			*pRet = 0;
			while (err.IsEmpty()) {

                // All the heavy lifting is done in this call.
				int rc = searchDialog.DoModal();
				switch (rc) {
				case IDCANCEL:
					return S_OK;
				case -1:
				default:
					::AfxMessageBox("Internal error");
					return S_OK;
				}
			}
		}
	}
	catch (...) {
        ::AfxMessageBox("Unexpected exception encountered.");
        *pRet = 6;
    }

	return S_OK;
}

/**
 * Save the currently active document in the CDR repository.
 *
 *  @param  pRet    address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::save(int *pRet)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	*pRet = 0;
	try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox("This session is not logged into the CDR");
            *pRet = 6;
            return S_OK;
        }

        // Get the currently active document.
        _Document doc = cdr::getApp().GetActiveDocument();
        if (!doc) {
            ::AfxMessageBox("There is no active document.");
            *pRet = 3;
            return S_OK;
        }

        // Extract control information from the document.
		DOMNode docElement = doc.GetDocumentElement();
		CdrDocCtrlInfo ctrlInfo;
        cdr::extractCtlInfo(docElement, ctrlInfo);
		CString docTitle = ctrlInfo.docTitle.c_str();

        // Ask the user for options to be used for the operation.
		CSaveDialog saveDialog(docTitle, 0);
		switch (saveDialog.DoModal()) {
		case IDOK:
		{
            CWaitCursor wc;

            // Build the save command.
        	std::ostringstream os;
            std::string docTitle = cdr::encode((std::string)saveDialog.m_title);
            std::string cmdTag = ctrlInfo.docId.empty() ? "CdrAddDoc" 
                                                        : "CdrRepDoc";
			os << "<" << cmdTag << "><CheckIn>"
			   << (saveDialog.m_checkIn ? "Y" : "N")
			   << "</CheckIn><Validate>"
			   << (saveDialog.m_validate ? "Y" : "N")
			   << "</Validate>";
			if (!saveDialog.m_comment.IsEmpty())
				os << "<Reason>" 
                   << cdr::encode(std::string(saveDialog.m_comment))
				   << "</Reason>";
			os << "<CdrDoc Type='" << ctrlInfo.docType << "'";
            if (!ctrlInfo.docId.empty())
                os << " Id='" << ctrlInfo.docId << "'";
			os << "><CdrDocCtl>";
            if (!ctrlInfo.docId.empty()) {
                ::AfxMessageBox("docId is not empty!");
                os << "<DocId>" << ctrlInfo.docId << "</DocId>";
            }
			os << "<DocType>" << ctrlInfo.docType << "</DocType>";
			os << "<DocTitle>" << ctrlInfo.docTitle << "</DocTitle></CdrDocCtl>";
			os << "<CdrDocXml><![CDATA[" << docElement << "]]></CdrDocXml>";
			os << "</CdrDoc></" << cmdTag << ">";

            // Submit the save command to the server.
            std::string rsp = CdrSocket::sendCommand(os.str());
            if (rsp.find("<Error") != rsp.npos) {
                cdr::showErrors(rsp);
                *pRet = 2;
            }
			break;
		}
		case IDCANCEL:
			*pRet = 1;
			break;
		}
	}
	catch (...) {
        ::AfxMessageBox("Unexpected exception encountered.");
        *pRet = 6;
    }
	return S_OK;
}

/**
 * Ask the CDR server to validate the currently active document.
 *
 *  @param  pRet    address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::validate(int *pRet)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	*pRet = 0;
    
	try {

        // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox("This session is not logged into the CDR");
            *pRet = 6;
            return S_OK;
        }

        // Ask the user for options to be used during validation.
		CValidateDialog validateDialog;
		switch (validateDialog.DoModal()) {
		case IDOK:
		{
            CWaitCursor wc;

            // Find the currently active document.
            _Document doc = cdr::getApp().GetActiveDocument();

            // Extract the document's control information.
		    DOMNode docElement = doc.GetDocumentElement();
		    CdrDocCtrlInfo ctrlInfo;
            cdr::extractCtlInfo(docElement, ctrlInfo);
            std::string docType = docElement.GetNodeName();

            // Build the validate command.
            std::ostringstream os;
            os << "<CdrValidateDoc DocType='" << docType 
               << "' ValidationTypes='";

            // Dialog box ensures that at least one is true.
            const char* separator = "";
            if (validateDialog.m_schemaValidation) {
                os << "Schema";
                separator = " ";
            }
            if (validateDialog.m_linkValidation)
                os << separator << "Links";
            os << "'><CdrDoc Type='" << docType << "'><CdrDocCtl>";
            if (!ctrlInfo.docId.empty())
                os << "<DocId>" << ctrlInfo.docId << "</DocId>";
            os << "<DocTitle>" << ctrlInfo.docTitle << "</DocTitle></CdrDocCtl>"
                  "<CdrDocXml><![CDATA[" << docElement << "]]></CdrDocXml>"
                  "</CdrDoc></CdrValidateDoc>";
            std::string cmd = os.str();

            // Submit the validate command to the server.
            std::string rsp = CdrSocket::sendCommand(cmd);
            if (rsp.find("<Error") != rsp.npos) {
                cdr::showErrors(rsp);
                *pRet = 1;
            }
            else
                ::AfxMessageBox("Document passes validation.");
            break;
        }
		case IDCANCEL:
			*pRet = 1;
			break;
		}
	}
	catch (...) { 
        ::AfxMessageBox("Unexpected error from validation command."); 
        *pRet = 2; 
    }
	return S_OK;
}

/**
 * Log out of the CDR server.
 *
 *  @param  pRet    address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::logoff(int *pRet)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

    // Initial optimism.
	*pRet = 0;

    try {

	    // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox("This session is not logged into the CDR");
            *pRet = 1;
            return S_OK;
        }

        // Submit the logoff request to the server.
        std::string rsp = CdrSocket::sendCommand("<CdrLogoff/>");
        if (rsp.find("<Error") != rsp.npos) {
            cdr::showErrors(rsp);
            *pRet = 2;
        }
    }
    catch (...) {
        ::AfxMessageBox("Unexpected error from logoff command."); 
        *pRet = 3; 
    }

    // Clear the session string so we'll know that we're no longer logged in.
    CdrSocket::setSessionString("");
	return S_OK;
}

/**
 * Allows user to edit the current node, which represents a link to
 * another CDR document.
 *
 *  @param  pRet    address of value returned for Microsoft Automation.
 */
STDMETHODIMP CCommands::edit(int *pRet)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

    // Initial optimism.
	*pRet = 0;

    try {

	    // Make sure the user is logged on to the CDR.
        if (!CdrSocket::loggedOn()) {
            ::AfxMessageBox("This session is not logged into the CDR");
            *pRet = 1;
            return S_OK;
        }

        // Find the currently active document.
        _Document doc = cdr::getApp().GetActiveDocument();

        // Extract the control information from the document.
		DOMNode docElement = doc.GetDocumentElement();
		CdrDocCtrlInfo ctrlInfo;
        cdr::extractCtlInfo(docElement, ctrlInfo);
        std::string docType = docElement.GetNodeName();

        // Find the element with the current focus.
        ::Selection selection = cdr::getApp().GetSelection();
        std::string elemName = selection.GetContainerName();

        // Most of the real work is done inside this call.
        CEditElement editDialog(docType, elemName);
		editDialog.DoModal();
    }
    catch (...) {
        ::AfxMessageBox("Unexpected error from edit command."); 
        *pRet = 2; 
    }
	return S_OK;
}

/**
 * Common public method which factors out the code to retrieve and
 * open a CDR document.
 *
 *  @param  id              reference to CDR document ID.
 *  @return                 <code>true</code> if document retrieved
 *                          successfully.
 */
bool CCommands::doRetrieve(const std::string& id)
{
    // Working variables.
    unsigned int docNo = cdr::getDocNo(id);
	CString err;
    CString docPath;
    CString docId;
    CString retrievedDocTitle;
    std::string cdrDoc;
	std::string docTitle;
    std::string cdrPath = cdr::getXmetalPath() + "\\Cdr";

    // Build up path strings.
    docPath.Format("%s\\CDR%u.xml", cdrPath.c_str(), docNo);
    docId.Format("CDR%010u", docNo);

    // Ask the server for the document.
    std::string request = "<CdrGetDoc><DocId>" 
                        + docId 
                        + "</DocId></CdrGetDoc>";
	std::string response = CdrSocket::sendCommand(request);
    if (response.empty())
        err = "Empty response from server";

    // Extract the CdrDoc element.
    else {
        TinyXmlParser parser(response);
        int begin = response.find("<CdrDoc ");
        if (begin == response.npos) {
            std::string serverErr = parser.extract("Err");
            if (serverErr.empty())
                err = "Unknown failure retrieving document from CDR";
            else
                err = serverErr.c_str();
        }
        else {
            int end = response.find("</CdrDoc>", begin);
            if (end == response.npos)
                err = "Malformed response from server";
            else {
                cdrDoc = response.substr(begin, (end - begin) + 9);
				docTitle = parser.extract("DocTitle");
				retrievedDocTitle.Format("%s (CDR%u)", 
					                     docTitle.c_str(), docNo);
			}
        }
    }

    // Extract the DocXml.
    std::string docXml;
    if (!cdrDoc.empty()) {
        size_t cdata = cdrDoc.find("<![CDATA[");
        if (cdata == cdrDoc.npos)
            err = "Malformed document: missing CDATA section";
        else {
            cdata += 9;
            size_t endCdata = cdrDoc.find("]]>", cdata);
            if (endCdata == cdrDoc.npos)
                err = "Malformed document: missing CDATA end delimiter";
            else
                docXml = cdrDoc.substr(cdata, endCdata - cdata);
        }
    }

    // Extract the document type.
    std::string docType;
    if (!docXml.empty()) {
        size_t nameStart = docXml.find('<');
        if (nameStart == docXml.npos)
            err = "Malformed document: missing top element";
        else {
            size_t nameEnd = docXml.find_first_of("\t\n\r >", ++nameStart);
            if (nameEnd == docXml.npos || nameEnd == nameStart)
                err = "Malformed document: can't find element name end";
            else
                docType = docXml.substr(nameStart, nameEnd - nameStart);
        }
    }

    // Write out the document.
    if (!docType.empty()) {
        std::ofstream xmlStream((const char *)docPath);
        if (!xmlStream)
            err.Format("Can't write xml document at %s", (const char*)docPath);
        else {
            std::string ctl = std::string("<CdrDocCtl><DocId>")
                            + (const char *)docId
                            + "</DocId><DocTitle>"
                            + cdr::encode(docTitle, true)
                            + "</DocTitle></CdrDocCtl>";
            xmlStream << "<!DOCTYPE " 
                      << docType
                      << " SYSTEM '" 
                      << docType 
                      << ".dtd'>\n"
                      << fixDoc(docXml, ctl);
        }
    }

    // Show any bad news to the user.
    if (!err.IsEmpty()) {
        ::AfxMessageBox(err, MB_ICONEXCLAMATION);
        return false;
	}
	else {

        // Open the document and set its title bar string.
        _Application app = cdr::getApp();
        Documents docs = app.GetDocuments();
        _Document doc = docs.Open((const char*)docPath, 1);
        if (doc) {
            doc.SetTitle(retrievedDocTitle);
            return true;
        }
        return false;
	}
}
#if 0
/**
 * Common public method which factors out the code to retrieve and
 * open a CDR document.
 *
 *  @param  id              reference to CDR document ID.
 *  @return                 <code>true</code> if document retrieved
 *                          successfully.
 */
bool CCommands::doRetrieve(const std::string& id)
{
    // Working variables.
    unsigned int docNo = cdr::getDocNo(id);
	CString err;
    CString docPath;
    CString docId;
    CString retrievedDocTitle;
    std::string cdrDoc;
	std::string docTitle;
    std::string cdrPath = cdr::getXmetalPath() + "\\Cdr";

    // Build up path strings.
    docPath.Format("%s\\CDR%u.xml", cdrPath.c_str(), docNo);
    docId.Format("CDR%010u", docNo);

    // Ask the server for the document.
    std::string request = "<CdrGetDoc><DocId>" 
                        + docId 
                        + "</DocId></CdrGetDoc>";
	std::string response = CdrSocket::sendCommand(request);
    if (response.empty())
        err = "Empty response from server";

    // Extract the CdrDoc element.
    else {
        TinyXmlParser parser(response);
        int begin = response.find("<CdrDoc ");
        if (begin == response.npos) {
            std::string serverErr = parser.extract("Err");
            if (serverErr.empty())
                err = "Unknown failure retrieving document from CDR";
            else
                err = serverErr.c_str();
        }
        else {
            int end = response.find("</CdrDoc>", begin);
            if (end == response.npos)
                err = "Malformed response from server";
            else {
                cdrDoc = response.substr(begin, (end - begin) + 9);
				docTitle = parser.extract("DocTitle");
				retrievedDocTitle.Format("%s (CDR%u)", 
					                     docTitle.c_str(), docNo);
			}
        }
    }

    // Extract the DocXml.
    std::string docXml;
    if (!cdrDoc.empty()) {
        size_t cdata = cdrDoc.find("<![CDATA[");
        if (cdata == cdrDoc.npos)
            err = "Malformed document: missing CDATA section";
        else {
            cdata += 9;
            size_t endCdata = cdrDoc.find("]]>", cdata);
            if (endCdata == cdrDoc.npos)
                err = "Malformed document: missing CDATA end delimiter";
            else
                docXml = cdrDoc.substr(cdata, endCdata - cdata);
        }
    }

    // Extract the document type.
    std::string docType;
    if (!docXml.empty()) {
        size_t nameStart = docXml.find('<');
        if (nameStart == docXml.npos)
            err = "Malformed document: missing top element";
        else {
            size_t nameEnd = docXml.find_first_of("\t\n\r >", ++nameStart);
            if (nameEnd == docXml.npos || nameEnd == nameStart)
                err = "Malformed document: can't find element name end";
            else
                docType = docXml.substr(nameStart, nameEnd - nameStart);
        }
    }

    // Write out the document.
    if (!docType.empty()) {
        std::ofstream xmlStream((const char *)docPath);
        if (!xmlStream)
            err.Format("Can't write xml document at %s", (const char*)docPath);
        else {
            std::string ctl = std::string("<CdrDocCtl><DocId>")
                            + (const char *)docId
                            + "</DocId><DocTitle>"
                            + cdr::encode(docTitle, true)
                            + "</DocTitle></CdrDocCtl>";
            xmlStream << "<!DOCTYPE " 
                      << docType
                      << " SYSTEM '" 
                      << docType 
                      << ".dtd'>\n"
                      << fixDoc(docXml, ctl);
        }
    }

    // Show any bad news to the user.
    if (!err.IsEmpty()) {
        ::AfxMessageBox(err, MB_ICONEXCLAMATION);
        return false;
	}
	else {

        // Open the document and set its title bar string.
        _Application app = cdr::getApp();
        Documents docs = app.GetDocuments();
        _Document doc = docs.Open((const char*)docPath, 1);
        if (doc) {
            doc.SetTitle(retrievedDocTitle);
            return true;
        }
        return false;
	}
}
#endif
/**
 * Populates the list of document type strings used to narrow a
 * user's CDR document search request.
 *
 *  @param  err         reference to string used to report any problems
 *                      encountered during population of the list.
 */
void getDocTypeStrings(CString& err)
{
    // Ask the user for the list of document types.
	std::string response = CdrSocket::sendCommand("<CdrListDocTypes/>");
    if (response.empty())
		err = "Empty response from server";

    // Parse the type names from the server's response.
	if (err.IsEmpty()) {
		docTypeStrings.push_back("Any Type");
		size_t pos = 0;
		while ((pos = response.find("<DocType>", pos)) != response.npos) {
			pos += 9;
			size_t endPos = response.find("</DocType>", pos);
			if (endPos == response.npos || endPos == pos) {
				err = "Malformed response for document type list";
				break;
			}

            // Add the document type to the list.
			std::string typeName = response.substr(pos, endPos - pos);
			docTypeStrings.push_back(typeName);
			pos = endPos + 10;
		}
    }
}

/**
 * Performs a few cleanup tasks needed to prepare the CDR document
 * for editing inside XMetaL.  This primarily involves the insertion
 * of the CdrDocCtl element.  In addition, a couple of temporary
 * steps are performed if they haven't already happened at data
 * conversion time (stripping out whitespace between elements and
 * adding the namespace declaration for the 'cdr' namespace).
 * XXX remove these extra steps after the next document conversion
 * run is performed.
 *
 *  @param  doc             reference to XML for document retrieved
 *                          from the CDR server.
 *  @param  ctl             reference to string containing CdrDocCtl
 *                          element to be inserted.
 *  @return                 reference to modified document string.
 */
std::string& fixDoc(std::string& doc, const std::string& ctl)
{
	// Skip leading whitespace.
	size_t pos = 0;
	while (isspace(doc[pos]))
		++pos;
	doc.erase(0, pos);
	pos = doc.find('>');
	if (pos == doc.npos)
		return doc;

    // Insert the CdrDocCtl element.
    doc.insert(pos + 1, ctl);

    // Add the 'cdr' namespace declaration if it's not already present.
	if (doc.find(" xmlns:cdr") == doc.npos)
		doc.insert(pos, " xmlns:cdr='cips.nci.nih.gov/cdr'");

    // Strip out whitespace between elements.
	while ((pos = doc.find('>', pos)) != doc.npos) {
		++pos;
		size_t n = 0;
		while (isspace(doc[pos + n]))
			++n;
		if (n)
			doc.erase(pos, n);
	}
	return doc;
}

/**
 * Parses document ID and denormalized value from string argument
 * and inserts the former as a cdr:ref attribute and the latter
 * as the text content of the current element.  Private support
 * method.
 *
 *  @param  info    string returned by server containing document
 *                  ID and denormalized value for a link target;
 *                  the format of this string is "[id] text-content".
 *  @return         <code>true</code> if link inserted successfully.
 */
bool CCommands::doInsertLink(const std::string& info)
{
    // Parse out the document ID and text content.
    size_t pos = info.find("[");
    if (pos == info.npos) {
        ::AfxMessageBox("Unable to find document ID start delimiter.");
        return false;
    }
    size_t endPos = info.find("]", ++pos);
    if (endPos == info.npos) {
        ::AfxMessageBox("Unable to find document ID end delimiter.");
        return false;
    }
    std::string targetDocId = info.substr(pos, endPos - pos);
    pos = endPos + 1;
    while (pos < info.size() && info[pos] == ' ')
        ++pos;
    std::string targetDocTitle = info.substr(pos);

    // Find the source element for the link.
    ::Selection selection = cdr::getApp().GetSelection();
    selection.SetReadOnlyContainer(FALSE);
    ::DOMNode node = selection.GetContainerNode();
    while (node && node.GetNodeType() != 1) // DOMElement
        node = node.GetParentNode();
    if (node) {

        // This is the MS Automation equivalent of 'casting'.  It is
        // necessary to turn off the auto-release flag for the second
        // object to prevent too many invocations of IUnknown::Release().
        ::DOMElement elem(node);
        elem.m_bAutoRelease = 0;

        // Plug in the link attribute.
        elem.setAttribute("cdr:ref", targetDocId.c_str());

        // Find the text node for the element.
        ::DOMNode child = node.GetFirstChild();
        while (child && child.GetNodeType() != 3) // DOMText
            child = child.GetNextSibling();
        if (child) {

            // See note above about "casting".
            ::DOMText textNode(child);
            textNode.m_bAutoRelease = 0;

            // Replace the text node with the linked document's title.
            long len = textNode.GetLength();
            const char* pTitle = targetDocTitle.c_str();
            textNode.replaceData(0, len, pTitle);
        }
    }

    // The user cannot edit the element directly.
    selection.SetReadOnlyContainer(TRUE);
    return true;
}
