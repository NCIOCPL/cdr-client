/*
 * $Id: CdrClient.h,v 1.1.1.1 2005-11-08 21:30:20 bkline Exp $
 *
 * Interface file for CDR loader application.
 *
 * $Log: not supported by cvs2svn $
 */

/*
 * Preprocessor directives generated by Visual Studio wizard.
 */
#pragma once
#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif
#include "resource.h"

/*
 * Header files added for this program.
 */
#include <atlbase.h>
#include <msxml.h>
#include <vector>
#include <list>
#include <set>
#include <string>
#include <afxinet.h>
#include <fstream>
#include "CdrProgressDlg.h"

/*
 * Fixed names.
 */
#define RECURSIVE_SCRIPT _T("LaunchCdrClientRecursively.cmd")
#define MANIFEST_FILE    _T("CdrManifest.xml")
#define SETTINGS_FILE    _T("CdrSettings.xml")
#define PROD_GROUP       _T("PRODUCTION")
#define TEST_GROUP       _T("TEST")
#define DEV_GROUP        _T("DEV")

/*
 * Forward references.
 */
class CdrLoginDlg;
class LogFile;

/*
 * These are the values used for connecting to the CDR server and the
 * client files refresh server.  There are three groups of these
 * servers (and the values used to connect to them), one each for
 * production, testing, and development.  This object also remembers
 * the currently selected group, as well as the current CDR user ID.
 * There are methods available for finding a group by its name,
 * and for serializing the values held by the object in a persistent
 * XML file on the user's local disk.
 *
 * The structure of the XML document containing these settings
 * looks like this:
 *
 *  CDRServerSettings
 *    CurrentUser [string]
 *    CurrentGroup [string]
 *    ServerGroup [multiple]
 *      @Name
 *      UpdateServer [string]
 *      UpdatePort [decimal number]
 *      CdrServer [string]
 *      CdrPort [decimal number]
 */
struct ServerSettings {
    ServerSettings(CComPtr<IXMLDOMDocument>& xmlDomParser);

    /*
     * Each group has a name, as well as values (DNS names and TCP/IP
     * ports) for connecting to the CDR server and client refresh
     * server in the group.  The group object knows how to generate
     * an XML representation of itself.
     */
    struct ServerGroup {
        ServerGroup(CComPtr<IXMLDOMNode>& node);
        CString groupName;
        CString updateServer;
        CString updatePort;
        CString cdrServer;
        CString cdrPort;
        void serialize(CStdioFile&) const;
    };
    ServerGroup* findGroup(const CString& name);
    std::vector<ServerGroup> serverGroups;
    CString currentUser;
    CString currentGroup;
    void serialize(const CString& name) const;
};

/*
 * Run-time settings which can be set on the command line.  This class
 * is derived from the general MFC class for handling command-line
 * parameters.  The following options are supported:
 *
 *   --recurse:            This option is used when we are being invoked
 *                         recursively, which we must do when we have
 *                         just received a new version of this program
 *
 *   --server-debug-level  Used to control the amount of logging to
 *                         be performed by the server which sends us
 *                         new or updated client files.  The default
 *                         value is 1, which provides minimal logging.
 *                         Expects a decimal value.  Set to 0 to turn
 *                         off all logging except for failures.
 *
 *   --debug-level         Used to control the amount of logging to
 *                         be performed by this program.  The default
 *                         value is 1, similar to that used for
 *                         the server debug level.
 *
 *   --skip-recursion      Used to suppress recursive invocation of
 *                         this program, even when the server sends
 *                         us a new version of the program with a
 *                         script to invoke the program recursively.
 *                         Used during development for debugging.
 *
 *   --skip-login          Used during development and debugging
 *                         to suppress the login to the CDR server.
 *
 *   --skip-dialog         Used during development/debugging to
 *                         avoid displaying the login dialog and
 *                         the user modification of connection
 *                         values.
 *
 *   --skip-refresh        Don't download any new or changed
 *                         files from the server; don't even
 *                         check to see whether our files are
 *                         up to date.  Used during development
 *                         or to avoid downloading files which
 *                         may have unwanted changes.
 */
 class CdrCommandLineOptions : public CCommandLineInfo {
public:
    CdrCommandLineOptions();
    void ParseParam(const TCHAR* param, BOOL flag, BOOL last);
    bool skipCdrLogin;
    bool skipDialog;
    bool skipRefresh;
    bool skipRecursion;
    bool recurse;
    int  serverDebugLevel;
    int  clientDebugLevel;
private:
    CString currentOption;
};

/*
 * Main application object.  See documentation in implementation file
 * for explanations of the program's logic and structure.
 */
class CdrClient : public CWinApp {
public:
    CdrClient();
    ~CdrClient();
    void log(const CString& what, int level = 0);

public:
    // Override base class methods.
    virtual BOOL InitInstance();

private:
    // Implementation.
    void extractServerSettings();
    bool createCdrSession();
    void clearCaches();
    void refreshFiles();
    void launchRecursively();
    void launchClient();
    void exportEnvironment();
    void logOptions();
    void getNewFiles(const CString&, CdrProgressDlg&);
    void deleteFiles(const CString&, const std::set<CString>&);
    CString sendHttpCommand(const CString& cmd);
    CString extractSessionId(const CString& xmlString);
    CString httpServer;
    CString cdrServer;
    CString sessionId;
    INTERNET_PORT httpPort;
    INTERNET_PORT cdrPort;
    bool loaderReplaced;
    ServerSettings* serverSettings;
    CComPtr<IXMLDOMDocument> xmlDomParser;
    CdrLoginDlg* dialog;
    CdrCommandLineOptions commandLineOptions;
    LogFile* logger;

    // Generated by Visual Studio wizard.
    DECLARE_MESSAGE_MAP()
};

/*
 * This object represents the header from a manifest document identifying
 * the current set of client files we should have.  We send this to the
 * client refresh server so that it can determined whether any changes
 * have taken place since the last time we checked, without sending the
 * entire manifest file.  Since in most cases, no such changes have
 * occurred, this saves significant time and network bandwidth.  The
 * header records the name of the machine on which the manifest was
 * created, the date and time it was created, who ran the program
 * to create it, and what application was used to create it.  Only
 * the host name and manifest timestamp are used in the determination
 * of whether changes have taken place since the client's copy of
 * the manifest was created.  See comment below for Manifest type
 * for the header's XML structure.
 */
struct Ticket {
    Ticket(CComPtr<IXMLDOMNode>&);
    Ticket() {}
    CString application;
    CString timestamp;
    CString host;
    CString author;
};

/*
 * Records the pathname and timestamp for last modification of one of
 * the files listed in the manifest.  See comment below for Manifest
 * type for the XML structure.
 */
struct File {
    File(CComPtr<IXMLDOMNode>&);
    CString name;
    CString timestamp;
};

/*
 * Contains a list of all of the current CDR client files which should
 * be installed on the user's machine, as well as a header ("ticket")
 * used to determine whether the client machine's copy of the manifest
 * is current.  The validate() method walks through the list of
 * files in the manifest to ensure that the correct version of each
 * file is present on the user's disk.
 *
 * The structure for the manifest file looks like this:
 *
 *  MANIFEST
 *    TICKET
 *      APPLICATION [string]
 *      TIMESTAMP [date-time]
 *      HOST [string]
 *      AUTHOR [string]
 *    FILELIST
 *      FILE [multiple]
 *        NAME
 *        TIMESTAMP
 */
struct Manifest {
    Manifest(CComPtr<IXMLDOMDocument>&);
    Ticket ticket;
    CString ticketXml;
    CString manifestXml;
    std::vector<File> fileList;
    CString validate(CdrClient*);
};

/*
 * Represents the server's response to our request to determine
 * whether our manifest is out of date.  The XML document for
 * the server's response consists of only a single text-content
 * element named VALIDATION.
 */
struct TicketValidation {
    TicketValidation(CComPtr<IXMLDOMDocument>&, const CString&);
    CString response;
};

/*
 * Represents the results of the server's comparison of it's own
 * manifest file with the client's copy.  This object will have
 * a list of files that we said we have but are no longer on
 * the server's manifest, and should therefore be deleted, as
 * well as the name of a compressed archive of all the new or
 * changed files (if any) the server needs to send us.  If
 * there are no new or changed files, this name will be an
 * empty string.  If there are no files to be deleted, the
 * 'deletes' list will be empty.
 *
 * The server's response has the following structure:
 *
 *  DELTA
 *    ZIPFILE [string, optional]
 *    DELETE [optional]
 *      FILE [string, multiple]
 */
struct Delta {
    Delta(CComPtr<IXMLDOMDocument>&, const CString&);
    CString zipFile;
    std::list<CString> deletes;
};

/*
 * Represents the compressed archive sent by the server with
 * all of the new or changed files we need.  The object has
 * a string with the name of the archive file (not used by
 * the client, but can be useful in tracking down failures
 * if a problem occurs), as well as an in-memory string (with
 * single-byte characters) for the compressed archive.
 *
 * The XML structure for the server's response looks like this:
 *
 *  ZIPFILE
 *    FNAME [string]
 *    DATA [base64-encoded bytes for archive]
 *      @encoding [='base64']
 */
struct ZipFile {
    ZipFile(CComPtr<IXMLDOMDocument>&, const CString&);
    CString     name;
    std::string bytes;
};

/*
 * Object used to record logging information at runtime.  Unicode
 * strings are encoded as UTF-8 before being written to the log
 * file.
 */
class LogFile {
public:
    LogFile();
    ~LogFile() { logFile << std::endl; }
    void write(const CString& what);
private:
    std::ofstream logFile;
    static std::string cStringToUtf8(const CString&);
    static inline unsigned short charToUnsignedShort(TCHAR c) {
        #ifdef _UNICODE
            return static_cast<unsigned short>(c);
        #else
            unsigned char uc = static_cast<unsigned char>(c);
            return static_cast<unsigned short>(uc);
        #endif
    }
};

/*
 * Global object for the application.
 */
extern CdrClient theApp;
